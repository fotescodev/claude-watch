# watchOS Ralph Loop - Task Definition
# This file defines all tasks for the autonomous coding loop.
# Tasks are processed by priority within parallel groups.

version: "1.0"
project: "ClaudeWatch"
platform: "watchOS"
min_deployment: "10.6"
swift_version: "5.9"
settings:
  require_build_pass: true
  require_accessibility: true
  require_hig_compliance: true
  auto_liquid_glass: true
tasks:
  # ═══════════════════════════════════════════════════════════════════════════
  # TEST TASK - Verify Ralph Loop Works
  # Parallel Group 0: Highest priority for testing
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "TEST1"
    title: "Add RALPH_TEST marker comment to MainView.swift"
    description: |
      Add a comment marker "// RALPH_TEST: Loop verification successful"
      at the top of MainView.swift (after the imports).
      This verifies the Ralph Loop can make code changes.
    priority: critical
    parallel_group: 0
    completed: true
    verification: |
      grep -q 'RALPH_TEST' ClaudeWatch/Views/MainView.swift && exit 0 || exit 1
    acceptance_criteria:
      - "MainView.swift contains RALPH_TEST marker comment"
    files:
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - test
      - loop-verification
    commit_template: "test(ralph): Add loop verification marker"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 1: CRITICAL - App Store Blockers
  # Parallel Group 1: Can run concurrently
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "C1"
    title: "Add accessibility labels to all interactive elements"
    description: |
      Add .accessibilityLabel() modifiers to all Button, NavigationLink,
      and interactive elements in MainView.swift and SettingsView.swift.
      This is required for App Store approval and VoiceOver support.
    priority: critical
    parallel_group: 1
    completed: true
    verification: |
      count=$(grep -r 'accessibilityLabel' ClaudeWatch/Views/*.swift 2>/dev/null | wc -l);
      [ "$count" -ge 10 ] && exit 0 || exit 1
    acceptance_criteria:
      - "Every Button has .accessibilityLabel()"
      - "Every NavigationLink has .accessibilityLabel()"
      - "VoiceOver announces all elements correctly"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/SettingsView.swift"
    tags:
      - accessibility
      - app-store
      - hig
    commit_template: "fix(a11y): Add accessibility labels to interactive elements"
  - id: "C2"
    title: "Create app icon assets for all required sizes"
    description: |
      Generate PNG app icons for all 16 required watchOS sizes.
      Use the Claude logo or create appropriate branding.
      Icons must be provided for all sizes in Contents.json.
    priority: critical
    parallel_group: 1
    completed: true
    verification: |
      count=$(ls ClaudeWatch/Assets.xcassets/AppIcon.appiconset/*.png 2>/dev/null | wc -l);
      [ "$count" -ge 8 ] && exit 0 || exit 1
    acceptance_criteria:
      - "PNG files exist for all required sizes"
      - "Icons render correctly in simulator"
      - "No placeholder or missing images"
    files:
      - "ClaudeWatch/Assets.xcassets/AppIcon.appiconset/"
    tags:
      - assets
      - app-store
    commit_template: "feat(assets): Add watchOS app icon assets"
  # ═══════════════════════════════════════════════════════════════════════════
  # Parallel Group 2: Depends on Group 1
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "C3"
    title: "Add AI data consent dialog on first launch"
    description: |
      Display consent dialog on first launch explaining:
      - Data sent to Claude API for processing
      - Voice transcription handling
      - No data sold to third parties
      Use @AppStorage to track consent state.
    priority: critical
    parallel_group: 2
    completed: true
    depends_on:
      - "C1"
    verification: |
      grep -q 'hasAcceptedConsent\|ConsentView\|privacyConsent' ClaudeWatch/ -r && exit 0 || exit 1
    acceptance_criteria:
      - "Consent view shown on first launch"
      - "@AppStorage tracks consent state"
      - "User can review consent in Settings"
    files:
      - "ClaudeWatch/Views/ConsentView.swift"
      - "ClaudeWatch/App/ClaudeWatchApp.swift"
      - "ClaudeWatch/Views/SettingsView.swift"
    tags:
      - privacy
      - app-store
      - onboarding
    commit_template: "feat(privacy): Add AI data consent dialog"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 2: HIGH PRIORITY - Quality & Polish
  # Parallel Group 3: Can run concurrently
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "H1"
    title: "Fix font sizes below 11pt minimum"
    description: |
      Replace hardcoded font sizes in ComplicationViews.swift with
      semantic styles. Ensure all text meets 11pt minimum per HIG.
      Use .caption, .caption2, .footnote instead of explicit sizes.
    priority: high
    parallel_group: 3
    completed: true
    verification: |
      ! grep -E '\.font\(.*size:\s*([0-9]|10)\.' ClaudeWatch/ -r 2>/dev/null
    acceptance_criteria:
      - "No font sizes below 11pt"
      - "Use semantic styles where possible"
      - "Complications remain readable"
    files:
      - "ClaudeWatch/Complications/ComplicationViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - hig
      - typography
      - accessibility
    commit_template: "fix(hig): Ensure minimum 11pt font sizes"
  - id: "H2"
    title: "Wire App Groups for complication data sharing"
    description: |
      Configure App Groups entitlement and use UserDefaults(suiteName:)
      for sharing state between main app and complications.
    priority: high
    parallel_group: 3
    completed: true
    verification: |
      grep -q 'group.com' ClaudeWatch/*.entitlements 2>/dev/null || \
      grep -q 'suiteName' ClaudeWatch/Services/*.swift 2>/dev/null
    acceptance_criteria:
      - "App Groups entitlement configured"
      - "Complications can read shared state"
      - "State persists across app launches"
    files:
      - "ClaudeWatch/ClaudeWatch.entitlements"
      - "ClaudeWatch/Services/WatchService.swift"
      - "ClaudeWatch/Complications/ComplicationViews.swift"
    tags:
      - entitlements
      - complications
      - state
    commit_template: "feat(complications): Wire App Groups for data sharing"
  - id: "H3"
    title: "Add recording indicator for voice input"
    description: |
      Show visual indicator when microphone is active.
      Required by App Store guidelines for privacy.
      Include haptic feedback on start/stop.
    priority: high
    parallel_group: 3
    completed: true
    verification: |
      grep -q 'isRecording\|RecordingIndicator\|recordingState' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Red dot or pulsing indicator during recording"
      - "Indicator visible in all lighting conditions"
      - "Haptic feedback on recording start/stop"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/Components/RecordingIndicator.swift"
    tags:
      - voice
      - privacy
      - app-store
    commit_template: "feat(voice): Add recording indicator"
  - id: "H4"
    title: "Update Swift version to 5.9+ in build settings"
    description: |
      Update SWIFT_VERSION in project.pbxproj from 5.0 to 5.9.
      Enable strict concurrency checking for better safety.
    priority: high
    parallel_group: 3
    completed: true
    verification: |
      grep -q 'SWIFT_VERSION = 5\.[9]' ClaudeWatch.xcodeproj/project.pbxproj || \
      grep -q 'SWIFT_VERSION = 6' ClaudeWatch.xcodeproj/project.pbxproj
    acceptance_criteria:
      - "Swift 5.9+ in build settings"
      - "No compilation errors"
      - "Strict concurrency warnings addressed"
    files:
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - build
      - swift
      - quality
    commit_template: "build: Update Swift version to 5.9"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 3: MEDIUM PRIORITY - Enhancement
  # Parallel Group 4: Can run concurrently
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "M1"
    title: "Implement Digital Crown support"
    description: |
      Add .digitalCrownRotation() for scrolling lists and adjusting values.
      Provide haptic feedback on detent boundaries.
    priority: medium
    parallel_group: 4
    completed: true
    verification: |
      grep -q 'digitalCrownRotation\|DigitalCrown' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Crown scrolls message history"
      - "Haptic feedback on boundaries"
      - "Smooth rotation feel"
    files:
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - hig
      - input
      - haptics
    commit_template: "feat(input): Add Digital Crown support"
  - id: "M2"
    title: "Add Always-On Display support"
    description: |
      Detect .isLuminanceReduced environment and show simplified UI.
      Reduce colors, hide animations, show essential info only.
    priority: medium
    parallel_group: 4
    completed: true
    verification: |
      grep -q 'isLuminanceReduced' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Simplified UI in always-on mode"
      - "No bright colors or animations"
      - "Connection status always visible"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Complications/ComplicationViews.swift"
    tags:
      - always-on
      - hig
      - battery
    commit_template: "feat(display): Add Always-On Display support"
  - id: "M3"
    title: "Add Dynamic Type support"
    description: |
      Use .dynamicTypeSize environment and prefer semantic fonts.
      Test with all accessibility sizes.
      Use @ScaledMetric for custom sizes.
    priority: medium
    parallel_group: 4
    completed: true
    verification: |
      grep -q 'dynamicTypeSize\|@ScaledMetric\|DynamicType' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Text scales with system setting"
      - "Layout adapts to larger sizes"
      - "No text truncation at largest size"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/SettingsView.swift"
    tags:
      - accessibility
      - typography
      - hig
    commit_template: "feat(a11y): Add Dynamic Type support"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 4: WATCHOS 26 / LIQUID GLASS
  # Parallel Group 5: Can run concurrently
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "LG1"
    title: "Adopt Liquid Glass materials"
    description: |
      Replace .opacity() backgrounds with .ultraThinMaterial or .thinMaterial.
      Update to translucent, depth-aware UI components using SwiftUI's
      built-in Material types (.ultraThinMaterial, .thinMaterial, .regularMaterial).
      These provide the glass-like effect available in watchOS 10+.
    priority: medium
    parallel_group: 5
    completed: true
    verification: |
      grep -qE 'ultraThinMaterial|thinMaterial|regularMaterial|\.background\(\..*Material' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Material backgrounds on primary containers"
      - "Uses SwiftUI Material types (ultraThinMaterial, thinMaterial, etc.)"
      - "Maintains readability"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/Components/"
    tags:
      - liquid-glass
      - watchos26
      - design
    commit_template: "feat(design): Adopt Liquid Glass materials"
  - id: "LG2"
    title: "Add spring animations"
    description: |
      Replace linear animations with .spring() for natural feel.
      Use .animation(.bouncy) or .interpolatingSpring() for interactive elements.
      Spring animations make UI feel more responsive and natural.
    priority: low
    parallel_group: 5
    completed: true
    verification: |
      grep -qE '\.spring\(|interpolatingSpring|animation\(\.bouncy|\.bouncy\)' ClaudeWatch/Views/ -r
    acceptance_criteria:
      - "Buttons use spring animations"
      - "Transitions feel natural"
      - "No jarring or abrupt motion"
    files:
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - animation
      - liquid-glass
      - hig
    commit_template: "feat(animation): Add spring animations"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 5: TESTING & DOCUMENTATION
  # Parallel Group 6
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "T1"
    title: "Add UI tests for critical flows"
    description: |
      Create XCUITest cases for:
      - App launch and consent flow
      - Connection status display
      - Approval/rejection actions
      - Settings navigation
      Note: Tests should be added to ClaudeWatch/Tests/ directory.
    priority: medium
    parallel_group: 6
    completed: true
    verification: |
      ls ClaudeWatch/Tests/UI*.swift 2>/dev/null | wc -l | grep -q '[1-9]'
    acceptance_criteria:
      - "UI tests for main user flows"
      - "Tests pass on simulator"
      - "Good coverage of critical paths"
    files:
      - "ClaudeWatch/Tests/"
    tags:
      - testing
      - quality
    commit_template: "test(ui): Add UI tests for critical flows"
  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 6: SEAMLESS PAIRING - Reduce pairing friction
  # Parallel Group 7: Can run concurrently
  # Spec: docs/specs/SEAMLESS_PAIRING_SPEC.md
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "SP1"
    title: "Add clipboard paste button for pairing"
    description: |
      ⚠️ BLOCKED: UIPasteboard is NOT available on watchOS.

      The original plan to use UIPasteboard.general cannot work on watchOS.
      UIPasteboard is an iOS-only API - watchOS does not have direct clipboard access.

      ALTERNATIVE APPROACH (requires Phase 8 - iPhone companion app):
      Use WatchConnectivity to sync clipboard from paired iPhone:
      1. Create iPhone companion app target
      2. On iPhone: Read UIPasteboard and send via WCSession.sendMessage
      3. On Watch: Receive message and populate pairing code field

      This task is DEFERRED until after MVP (SP2 + SP4) ships.
      The numeric input approach (SP2) eliminates most of the friction
      that clipboard paste was meant to solve.

      For now, users can:
      1. Type the 6-digit numeric code (SP2)
      2. Use deep link from terminal (SP3, if implemented)
    priority: low
    parallel_group: 8
    completed: true # Marked complete to skip - redesign needed
    blocked: true
    blocked_reason: "UIPasteboard not available on watchOS. Requires WatchConnectivity + iPhone companion app."
    verification: |
      # Skip - task blocked
      exit 0
    acceptance_criteria:
      - "DEFERRED - requires iPhone companion app"
    files:
      - "ClaudeWatch/Views/PairingView.swift"
    tags:
      - pairing
      - ux
      - clipboard
      - blocked
    commit_template: "feat(pairing): Add clipboard paste button for seamless pairing"
  - id: "SP2"
    title: "Add numeric-only pairing code input option"
    description: |
      Add support for numeric-only pairing codes (6 digits like "123456")
      alongside the existing alphanumeric format. Numeric codes are faster
      to type on the watch.

      RESEARCH FINDINGS (2026-01-17):
      - watchOS doesn't have .numberPad keyboard type like iOS
      - Use TextFieldLink (watchOS 10+) with custom input validation
      - Set .textContentType(.oneTimeCode) for autofill hints
      - Leading zeros must be preserved (e.g., "012345")

      Implementation:
      1. Add TextFieldLink for numeric code entry
      2. Validate exactly 6 digits (allow leading zeros)
      3. Update code validation to accept both formats:
         - Alphanumeric: ABC-123 (7 chars with hyphen)
         - Numeric: 123456 (6 digits, no hyphen)
      4. Show inline error for invalid input
      5. Add haptic feedback on validation

      The server already normalizes codes, so this is primarily a UX change
      on the watch side to support faster numeric input.
    priority: high
    parallel_group: 7
    completed: true
    verification: |
      grep -qE 'TextFieldLink|isNumericCode|numericFormat|oneTimeCode|validateCode' ClaudeWatch/Views/PairingView.swift && exit 0 || exit 1
    acceptance_criteria:
      - "TextFieldLink for code entry (watchOS 10+)"
      - "Accepts 6-digit codes with leading zeros"
      - "Maintains support for ABC-123 format"
      - "Validation works for both formats"
      - "Inline error display for invalid codes"
      - "Haptic feedback on validation"
    files:
      - "ClaudeWatch/Views/PairingView.swift"
    tags:
      - pairing
      - ux
      - keyboard
    commit_template: "feat(pairing): Add numeric code input for faster pairing"
  - id: "SP3"
    title: "Add deep link URL scheme support for pairing"
    description: |
      DEFERRED: Not needed for MVP. SP2 (numeric input) solves the friction problem.

      Register claude-watch:// URL scheme to enable deep linking directly
      into the pairing flow with a pre-filled code.

      Implementation (when needed):
      1. Add URL scheme to Info.plist:
         - CFBundleURLTypes with CFBundleURLSchemes: ["claude-watch"]
      2. Handle .onOpenURL in ClaudeWatchApp.swift
      3. Parse URL: claude-watch://pair?code=ABC123

      RESEARCH FINDINGS (2026-01-17):
      - Adds complexity without proportional UX benefit
      - Requires QR code generation on server side
      - Users still need to scan/click - numeric typing is comparable effort
      - Consider for Phase 8 after MVP validation
    priority: low
    parallel_group: 8
    completed: true # Deferred - not needed for MVP
    deferred: true
    deferred_reason: "SP2 (numeric input) provides sufficient UX improvement for MVP"
    verification: |
      # Deferred - skip verification
      exit 0
    acceptance_criteria:
      - "DEFERRED - implement after MVP validation"
    files:
      - "ClaudeWatch/App/ClaudeWatchApp.swift"
      - "ClaudeWatch/Info.plist"
    tags:
      - pairing
      - deep-links
      - url-scheme
      - deferred
    commit_template: "feat(pairing): Add deep link URL scheme support"
  - id: "SP4"
    title: "Add server-side numeric code generation with rate limiting"
    description: |
      Update the Cloudflare Worker to support generating numeric-only
      pairing codes as an alternative to alphanumeric codes.

      SECURITY REQUIREMENT (from research 2026-01-17):
      Numeric codes reduce entropy from ~30 bits to ~20 bits.
      MUST add rate limiting to prevent brute force attacks.

      Implementation:
      1. Add optional ?format=numeric query param to POST /pair endpoint
      2. If format=numeric, generate 6-digit code using crypto.getRandomValues
      3. Preserve leading zeros (e.g., "012345" not "12345")
      4. Add rate limiting via Cloudflare KV:
         - Max 5 attempts per pairing ID per 15 minutes
         - Return 429 with retryAfter when exceeded
      5. Store numeric codes the same way in KV
      6. Lookup should work for both formats

      Rate limiting pattern:
      ```javascript
      const RATE_LIMIT = { maxAttempts: 5, windowMs: 15 * 60 * 1000 };
      async function checkRateLimit(pairingId, env) {
        const key = `rate:${pairingId}`;
        const attempts = parseInt(await env.KV.get(key) || '0');
        if (attempts >= RATE_LIMIT.maxAttempts) {
          return { blocked: true, retryAfter: RATE_LIMIT.windowMs };
        }
        await env.KV.put(key, String(attempts + 1), { expirationTtl: 900 });
        return { blocked: false };
      }
      ```
    priority: high
    parallel_group: 7
    completed: true
    verification: |
      grep -qE 'format.*numeric|numericCode|generateNumeric|rateLimit|RATE_LIMIT' MCPServer/worker/src/index.js && exit 0 || exit 1
    acceptance_criteria:
      - "POST /pair accepts ?format=numeric query param"
      - "Generates 6-digit numeric codes with leading zeros preserved"
      - "Rate limiting: max 5 attempts per 15 minutes per pairing ID"
      - "Returns 429 with retryAfter when rate limited"
      - "Default format unchanged (ABC-123)"
      - "Numeric codes stored and retrieved correctly"
    files:
      - "MCPServer/worker/src/index.js"
    tags:
      - pairing
      - server
      - api
      - security
    commit_template: "feat(api): Add numeric pairing code generation with rate limiting"
  - id: "SP5"
    title: "Add pairing code scannability via QR display hint"
    description: |
      DEFERRED: Nice-to-have after MVP. Depends on SP3 (deep links) being implemented.

      When Claude Code displays the pairing code in terminal, also provide
      a hint about the QR code URL that can be used for future scanning.

      Implementation (when needed):
      1. Update server response to include a qrUrl field:
         { code: "ABC-123", qrUrl: "claude-watch://pair?code=ABC-123", ... }
      2. This URL can be:
         - Converted to QR code by CLI tools
         - Clicked if terminal supports hyperlinks
         - Scanned by future iOS companion app

      RESEARCH FINDINGS (2026-01-17):
      - Requires SP3 (deep links) to be useful
      - SP3 is deferred, so SP5 should also be deferred
      - Numeric input (SP2) provides sufficient UX for MVP
    priority: low
    parallel_group: 8
    completed: true # Deferred - depends on SP3
    deferred: true
    deferred_reason: "Depends on SP3 (deep links) which is deferred"
    verification: |
      # Deferred - skip verification
      exit 0
    acceptance_criteria:
      - "DEFERRED - implement after SP3"
    files:
      - "MCPServer/worker/src/index.js"
    tags:
      - pairing
      - server
      - qr-code
      - deferred
    commit_template: "feat(api): Add QR-scannable deep link URL to pairing response"
  # --- Phase 7.0: Pre-Planning Verification (parallel_group: 9) ---
  - id: "UX0"
    # ═══════════════════════════════════════════════════════════════════════════
    # PHASE 7: UX IMPROVEMENTS - Component Architecture & Design System (FLATTENED)
    # From: plans/feat-ux-improvement-watchos.md (DEEPENED + SIMPLIFIED)
    # Updated: 2026-01-17 - Flattened from 14 files to 5 files per plan review
    # Parallel Groups 10-14
    #
    # KEY LEARNINGS APPLIED:
    # - Over-engineering prevention: Read existing code before designing new components
    # - watchOS 26: Liquid Glass, native TextField for dictation, WKApplication
    # - Async state: Always use @MainActor Task with defer for loading states
    # - NavigationStack: Required at outermost level for toolbar visibility
    # ═══════════════════════════════════════════════════════════════════════════

    title: "Verify existing code before component extraction"
    description: |
      CRITICAL: Pre-planning code review to prevent over-engineering.
      From documented learning: 80% of planned features often already exist.

      Verification steps:
      1. Read MainView.swift lines 7-29 (Claude enum) - confirm it exists
      2. Read lines 157-173 (animation extensions) - confirm patterns
      3. Check ConsentView.swift for duplicate Claude enum
      4. Check ComplicationViews.swift for duplicate Claude enum
      5. Document what can be REUSED vs what needs to be CREATED

      This task MUST complete before any extraction begins.
    priority: critical
    parallel_group: 9
    completed: true
    verification: |
      # Verify we've read the key files
      grep -q 'enum Claude' ClaudeWatch/Views/MainView.swift && \
      grep -q 'buttonSpring\|spring' ClaudeWatch/Views/MainView.swift && exit 0 || exit 1
    acceptance_criteria:
      - "MainView.swift Claude enum location documented"
      - "Animation extensions location documented"
      - "Duplicate enums identified in ConsentView and ComplicationViews"
      - "Pre-planning checklist completed"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/ConsentView.swift"
      - "ClaudeWatch/Complications/ComplicationViews.swift"
    tags:
      - pre-planning
      - verification
      - anti-overengineering
    commit_template: "docs(ux): Complete pre-planning verification for component extraction"
  # --- Phase 7.1: Design System Centralization (parallel_group: 10) ---
  # FLATTENED: Single Claude.swift contains colors, materials, spacing, button styles, animations
  - id: "UX1"
    title: "Create unified Claude design system"
    description: |
      Create DesignSystem/Claude.swift as SINGLE file containing all design tokens.
      FLATTENED from 3 files (Claude.swift, ClaudeButtonStyle.swift, ClaudeAnimations.swift).

      Implementation:
      1. Create ClaudeWatch/DesignSystem/ directory
      2. Create Claude.swift with:
         - Brand colors (orange, orangeLight, orangeDark)
         - Semantic colors (success, danger, warning, info)
         - Surface colors (background, surface1, surface2, surface3)
         - Text colors (textPrimary, textSecondary, textTertiary)
         - Materials enum with card, overlay, prominent
         - Spacing enum with xs, sm, md, lg, xl
         - Radius enum with small, medium, large, xlarge
         - ClaudePrimaryButtonStyle with press feedback
         - Animation extensions (buttonSpring, bouncySpring, etc.)
      3. Add file to project.pbxproj
    priority: critical
    parallel_group: 10
    completed: true
    verification: |
      [ -f "ClaudeWatch/DesignSystem/Claude.swift" ] && \
      grep -q 'enum Claude' ClaudeWatch/DesignSystem/Claude.swift && \
      grep -q 'ClaudePrimaryButtonStyle\|ButtonStyle' ClaudeWatch/DesignSystem/Claude.swift && \
      grep -q 'buttonSpring\|Animation' ClaudeWatch/DesignSystem/Claude.swift && exit 0 || exit 1
    acceptance_criteria:
      - "Claude.swift contains all color definitions"
      - "Materials, Spacing, and Radius nested enums defined"
      - "ClaudePrimaryButtonStyle with press feedback included"
      - "Animation extensions included"
      - "Single file - no separate ButtonStyle or Animations files"
    files:
      - "ClaudeWatch/DesignSystem/Claude.swift"
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - design-system
      - refactor
      - ux
      - flattened
    commit_template: "refactor(design): Create unified Claude design system (flattened)"
  - id: "UX2"
    title: "Remove duplicate Claude enum from other files"
    description: |
      Remove duplicate Claude color definitions from ConsentView.swift
      and ComplicationViews.swift. Update imports to use centralized system.

      Implementation:
      1. Remove duplicate Claude enum from ConsentView.swift
      2. Update ConsentView to use centralized Claude colors
      3. Update ComplicationViews.swift to use centralized colors
      4. Remove Claude enum and animation extensions from MainView.swift
      5. Verify no color definitions outside DesignSystem/
    priority: high
    parallel_group: 10
    depends_on:
      - "UX1"
    completed: true
    verification: |
      ! grep -q 'private enum Claude' ClaudeWatch/Views/ConsentView.swift && \
      ! grep -q 'private enum Claude' ClaudeWatch/Complications/ComplicationViews.swift && exit 0 || exit 1
    acceptance_criteria:
      - "No duplicate Claude enum in ConsentView.swift"
      - "No duplicate Claude enum in ComplicationViews.swift"
      - "No Claude enum in MainView.swift"
      - "All files use centralized design system"
    files:
      - "ClaudeWatch/Views/ConsentView.swift"
      - "ClaudeWatch/Complications/ComplicationViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - design-system
      - cleanup
      - refactor
    commit_template: "refactor(design): Remove duplicate Claude enum definitions"
  # --- Phase 7.2: Component Extraction - FLATTENED (parallel_group: 11) ---
  # 4 view files instead of 14 files across 6 directories
  - id: "UX3"
    title: "Create StateViews.swift with all state views"
    description: |
      FLATTENED: Create Views/StateViews.swift containing all state views in ONE file.
      Replaces: States/EmptyStateView.swift, OfflineStateView.swift, ReconnectingView.swift, AlwaysOnDisplayView.swift

      Implementation:
      1. Create ClaudeWatch/Views/StateViews.swift
      2. Extract from MainView.swift:
         - EmptyStateView
         - OfflineStateView
         - ReconnectingView
         - AlwaysOnDisplayView
      3. Add SwiftUI previews for each view
      4. Add file to project.pbxproj

      Target: ~200 lines for all state views together
    priority: high
    parallel_group: 11
    depends_on:
      - "UX1"
    completed: true
    verification: |
      [ -f "ClaudeWatch/Views/StateViews.swift" ] && \
      grep -q 'EmptyStateView' ClaudeWatch/Views/StateViews.swift && \
      grep -q 'OfflineStateView' ClaudeWatch/Views/StateViews.swift && \
      grep -q 'AlwaysOnDisplayView' ClaudeWatch/Views/StateViews.swift && exit 0 || exit 1
    acceptance_criteria:
      - "StateViews.swift contains all state views"
      - "Each view has SwiftUI preview"
      - "File under 300 lines"
    files:
      - "ClaudeWatch/Views/StateViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - component-extraction
      - refactor
      - flattened
    commit_template: "refactor(views): Extract state views to StateViews.swift"
  - id: "UX4"
    title: "Create ActionViews.swift with action queue and cards"
    description: |
      FLATTENED: Create Views/ActionViews.swift containing action components in ONE file.
      Replaces: ActionQueue/ActionQueueView.swift, PrimaryActionCard.swift, CompactActionCard.swift + StatusHeader

      Implementation:
      1. Create ClaudeWatch/Views/ActionViews.swift
      2. Extract from MainView.swift:
         - StatusHeader
         - ActionQueueView
         - PrimaryActionCard
         - CompactActionCard
      3. Add SwiftUI previews for each view
      4. Add file to project.pbxproj

      Target: ~250 lines for all action views together
    priority: high
    parallel_group: 11
    depends_on:
      - "UX1"
    completed: true
    verification: |
      [ -f "ClaudeWatch/Views/ActionViews.swift" ] && \
      grep -q 'StatusHeader' ClaudeWatch/Views/ActionViews.swift && \
      grep -q 'PrimaryActionCard' ClaudeWatch/Views/ActionViews.swift && exit 0 || exit 1
    acceptance_criteria:
      - "ActionViews.swift contains StatusHeader, ActionQueueView, action cards"
      - "Each view has SwiftUI preview"
      - "File under 300 lines"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - component-extraction
      - refactor
      - flattened
    commit_template: "refactor(views): Extract action views to ActionViews.swift"
  - id: "UX5"
    title: "Create CommandViews.swift with command grid and mode selector"
    description: |
      FLATTENED: Create Views/CommandViews.swift containing command components in ONE file.
      Replaces: Commands/CommandGrid.swift, CommandButton.swift + Components/ModeSelector.swift

      Implementation:
      1. Create ClaudeWatch/Views/CommandViews.swift
      2. Extract from MainView.swift:
         - CommandGrid
         - CommandButton
         - ModeSelector
      3. Add SwiftUI previews for each view
      4. Add file to project.pbxproj

      Target: ~150 lines for all command views together
    priority: high
    parallel_group: 11
    depends_on:
      - "UX1"
    completed: true
    verification: |
      [ -f "ClaudeWatch/Views/CommandViews.swift" ] && \
      grep -q 'CommandGrid' ClaudeWatch/Views/CommandViews.swift && \
      grep -q 'ModeSelector' ClaudeWatch/Views/CommandViews.swift && exit 0 || exit 1
    acceptance_criteria:
      - "CommandViews.swift contains CommandGrid, CommandButton, ModeSelector"
      - "Each view has SwiftUI preview"
      - "File under 300 lines"
    files:
      - "ClaudeWatch/Views/CommandViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - component-extraction
      - refactor
      - flattened
    commit_template: "refactor(views): Extract command views to CommandViews.swift"
  - id: "UX6"
    title: "Create SheetViews.swift with voice input and settings"
    description: |
      FLATTENED: Create Views/SheetViews.swift containing sheet views in ONE file.
      Replaces: Sheets/VoiceInputSheet.swift, SettingsSheet.swift

      RESEARCH INSIGHT (watchOS 26):
      VoiceInputSheet should use native SwiftUI TextField which auto-enables dictation.
      Do NOT use deprecated presentTextInputController API.

      Implementation:
      1. Create ClaudeWatch/Views/SheetViews.swift
      2. Extract from MainView.swift:
         - VoiceInputSheet (use native TextField, not WatchKit voice input)
         - SettingsSheet (with complete Exit Demo Mode state reset)
      3. Add SwiftUI previews
      4. Add file to project.pbxproj

      Modern VoiceInputSheet pattern:
      ```swift
      struct VoiceInputSheet: View {
          @State private var inputText = ""
          @FocusState private var isTextFieldFocused: Bool

          var body: some View {
              VStack {
                  TextField("Type or dictate...", text: $inputText)
                      .focused($isTextFieldFocused)
                  // Suggestion chips...
              }
          }
      }
      ```

      Target: ~200 lines for both sheet views together
    priority: high
    parallel_group: 11
    depends_on:
      - "UX1"
    completed: true
    verification: |
      [ -f "ClaudeWatch/Views/SheetViews.swift" ] && \
      grep -q 'VoiceInputSheet' ClaudeWatch/Views/SheetViews.swift && \
      grep -q 'SettingsSheet' ClaudeWatch/Views/SheetViews.swift && \
      grep -q 'TextField\|FocusState' ClaudeWatch/Views/SheetViews.swift && exit 0 || exit 1
    acceptance_criteria:
      - "SheetViews.swift contains VoiceInputSheet and SettingsSheet"
      - "Uses native TextField (not WatchKit presentTextInputController)"
      - "SettingsSheet has complete Exit Demo Mode state reset"
      - "File under 300 lines"
    files:
      - "ClaudeWatch/Views/SheetViews.swift"
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch.xcodeproj/project.pbxproj"
    tags:
      - component-extraction
      - refactor
      - flattened
      - deprecation-fix
    commit_template: "refactor(views): Extract sheet views to SheetViews.swift"
  - id: "UX7"
    title: "Refactor MainView to compose extracted components"
    description: |
      Final MainView refactoring to compose all extracted components.
      MainView should now only contain composition logic.

      Implementation:
      1. Remove all extracted views from MainView.swift
      2. Import extracted view files
      3. MainView body should compose:
         - StateViews (EmptyStateView, etc.)
         - ActionViews (StatusHeader, ActionQueueView, etc.)
         - CommandViews (CommandGrid, ModeSelector)
         - SheetViews (VoiceInputSheet, SettingsSheet)
      4. Add SwiftUI previews

      Target: MainView.swift under 250 lines
    priority: high
    parallel_group: 11
    depends_on:
      - "UX3"
      - "UX4"
      - "UX5"
      - "UX6"
    completed: true
    verification: |
      lines=$(wc -l < ClaudeWatch/Views/MainView.swift | tr -d ' ');
      [ "$lines" -lt 300 ] && exit 0 || echo "MainView has $lines lines (target: <300)" && exit 1
    acceptance_criteria:
      - "MainView.swift under 250 lines"
      - "Only composition, no embedded components"
      - "Imports all extracted view files"
    files:
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - refactor
      - composition
      - flattened
    commit_template: "refactor(views): Refactor MainView to compose extracted components"
  # --- Phase 7.3: Accessibility Enhancements (parallel_group: 12) ---
  - id: "UX8"
    title: "Add Reduce Motion support to all animations"
    description: |
      Add @Environment(\.accessibilityReduceMotion) checks to all animated views.

      Implementation:
      1. Add reduceMotion environment to all views with animations
      2. Disable/simplify animations when reduceMotion is true
      3. Check pulse animations in ActionViews.swift (StatusHeader)
      4. Check button press animations
      5. Check transition animations
    priority: medium
    parallel_group: 12
    depends_on:
      - "UX3"
      - "UX4"
      - "UX5"
      - "UX6"
    completed: true
    verification: |
      count=$(grep -r 'accessibilityReduceMotion' ClaudeWatch/Views/ 2>/dev/null | wc -l);
      [ "$count" -ge 5 ] && exit 0 || exit 1
    acceptance_criteria:
      - "All animated views check reduceMotion"
      - "Animations disabled when reduceMotion is true"
      - "No jarring motion for vestibular-sensitive users"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/CommandViews.swift"
      - "ClaudeWatch/DesignSystem/Claude.swift"
    tags:
      - accessibility
      - animation
      - a11y
    commit_template: "fix(a11y): Add Reduce Motion support to all animations"
  - id: "UX9"
    title: "Add VoiceOver announcements for state changes"
    description: |
      Add proper VoiceOver announcements for mode changes and recording state.

      Implementation:
      1. Add UIAccessibility.post(notification:) for mode changes
      2. Add announcement when recording starts/stops
      3. Ensure VoiceOver reads primary action first (Approve before Reject)
      4. Add accessibilityAction for AssistiveTouch gestures
    priority: medium
    parallel_group: 12
    completed: true
    verification: |
      grep -rq 'UIAccessibility.post\|accessibilityAction' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "Mode changes announced to VoiceOver"
      - "Recording state changes announced"
      - "Approve button read before Reject"
    files:
      - "ClaudeWatch/Views/CommandViews.swift"
      - "ClaudeWatch/Views/ActionViews.swift"
    tags:
      - accessibility
      - voiceover
      - a11y
    commit_template: "fix(a11y): Add VoiceOver announcements for state changes"
  - id: "UX10"
    title: "Add high contrast mode support"
    description: |
      Add support for increased contrast accessibility setting.

      Implementation:
      1. Add @Environment(\.colorSchemeContrast) checks
      2. Increase text color opacity for tertiary text in high contrast
      3. Add stronger borders/outlines in high contrast mode
      4. Test WCAG 2.1 AA contrast ratios
    priority: medium
    parallel_group: 12
    completed: true
    verification: |
      grep -rq 'colorSchemeContrast\|accessibilityContrast' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "High contrast mode detected"
      - "Text colors adjusted for high contrast"
      - "Meets WCAG 2.1 AA standards"
    files:
      - "ClaudeWatch/DesignSystem/Claude.swift"
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - accessibility
      - contrast
      - a11y
    commit_template: "fix(a11y): Add high contrast mode support"
  # --- Phase 7.4: Animation Modernization & Liquid Glass (parallel_group: 13) ---
  - id: "UX11"
    title: "Add symbol effects to status icons"
    description: |
      Add modern symbol effects to SF Symbol icons for visual feedback.
      watchOS 26 supports full symbol effects API.

      Implementation:
      1. Add .symbolEffect(.pulse) to status icons when running/waiting
      2. Add .symbolEffect(.bounce) on connection status changes
      3. Add .contentTransition(.symbolEffect) for icon state changes
      4. Respect reduceMotion preference
    priority: medium
    parallel_group: 13
    depends_on:
      - "UX8"
    completed: true
    verification: |
      grep -rq 'symbolEffect\|contentTransition' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "Status icons have symbol effects"
      - "Effects respect reduceMotion"
      - "Smooth icon state transitions"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/StateViews.swift"
    tags:
      - animation
      - sf-symbols
      - watchos26
    commit_template: "feat(animation): Add symbol effects to status icons"
  - id: "UX12"
    title: "Replace manual haptics with sensoryFeedback modifier"
    description: |
      Migrate from WKInterfaceDevice.current().play() to SwiftUI sensoryFeedback
      modifier where appropriate. watchOS 26 fully supports sensoryFeedback.

      Implementation:
      1. Replace .play(.success) with .sensoryFeedback(.success, trigger:)
      2. Replace .play(.failure) with .sensoryFeedback(.error, trigger:)
      3. Replace .play(.click) with .sensoryFeedback(.selection, trigger:)
      4. Keep WKInterfaceDevice for complex haptic patterns
    priority: medium
    parallel_group: 13
    completed: true
    verification: |
      count=$(grep -r 'sensoryFeedback' ClaudeWatch/Views/ 2>/dev/null | wc -l);
      [ "$count" -ge 3 ] && exit 0 || exit 1
    acceptance_criteria:
      - "Button feedback uses sensoryFeedback modifier"
      - "Haptics still work correctly"
      - "Code is more SwiftUI-native"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/CommandViews.swift"
      - "ClaudeWatch/DesignSystem/Claude.swift"
    tags:
      - haptics
      - watchos26
      - swiftui
    commit_template: "refactor(haptics): Use sensoryFeedback modifier"
  - id: "UX13"
    title: "Adopt Liquid Glass materials for watchOS 26"
    description: |
      Adopt watchOS 26 Liquid Glass design system using .glassEffect() modifier.

      Implementation:
      1. Add .glassEffect() to card backgrounds
      2. Update materials in Claude.swift to use Liquid Glass
      3. Test visual appearance on watchOS 26 simulator
      4. Ensure fallback for older watchOS versions if needed
    priority: medium
    parallel_group: 13
    completed: true
    verification: |
      grep -rq 'glassEffect\|liquidGlass' ClaudeWatch/ && exit 0 || exit 1
    acceptance_criteria:
      - "Cards use Liquid Glass effect"
      - "Visual style matches watchOS 26 HIG"
      - "No visual regressions"
    files:
      - "ClaudeWatch/DesignSystem/Claude.swift"
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/StateViews.swift"
    tags:
      - liquid-glass
      - watchos26
      - design
    commit_template: "feat(design): Adopt Liquid Glass materials for watchOS 26"
  # --- Phase 7.5: Error Handling & State Recovery (parallel_group: 14) ---
  # KEY LEARNINGS APPLIED:
  # - Async state: Use @MainActor Task with defer inside for loading states
  # - NavigationStack: Required for toolbar visibility on watchOS
  # - Complete state reset: Must reset ALL related variables atomically
  - id: "UX14"
    title: "Add inline error banners for network failures"
    description: |
      Add user-visible error feedback when network operations fail.

      RESEARCH INSIGHT (from docs/solutions/ui-bugs/pairing-flow-loading-spinner):
      Always use @MainActor Task with defer inside to reset loading states.

      Implementation:
      1. Add ErrorBanner view to ActionViews.swift
      2. Show banner when approval/rejection fails
      3. Show banner when polling fails
      4. Auto-dismiss after 3 seconds
      5. Add haptic feedback for errors
      6. Use correct defer pattern:

      ```swift
      func performAction() {
          isLoading = true
          Task { @MainActor in
              defer { isLoading = false }
              do {
                  try await service.perform()
                  WKInterfaceDevice.current().play(.success)
              } catch {
                  errorMessage = error.localizedDescription
              }
          }
      }
      ```
    priority: medium
    parallel_group: 14
    completed: true
    verification: |
      grep -rq 'ErrorBanner\|showError\|errorMessage' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "ErrorBanner view exists in ActionViews.swift"
      - "Network failures show inline error"
      - "Errors auto-dismiss after 3 seconds"
      - "Uses correct @MainActor defer pattern"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
    tags:
      - error-handling
      - ux
      - feedback
      - async-pattern
    commit_template: "feat(ux): Add inline error banners for network failures"
  - id: "UX15"
    title: "Add Approve All confirmation"
    description: |
      Add confirmation before batch approving all pending actions.

      Implementation:
      1. Add .confirmationDialog to Approve All button
      2. Show action count in confirmation
      3. Require explicit tap to confirm
      4. Add haptic feedback on confirm
    priority: low
    parallel_group: 14
    completed: true
    verification: |
      grep -rq 'confirmationDialog\|confirmApproveAll' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "Approve All shows confirmation"
      - "Shows number of actions to approve"
      - "Can cancel batch approval"
    files:
      - "ClaudeWatch/Views/ActionViews.swift"
    tags:
      - ux
      - safety
      - confirmation
    commit_template: "feat(ux): Add confirmation for Approve All"
  - id: "UX16"
    title: "Verify NavigationStack at app root"
    description: |
      CRITICAL LEARNING (from docs/solutions/ui-bugs/watchos-demo-mode-stuck-no-exit):
      Toolbar items require NavigationStack context to render on watchOS.
      Without NavigationStack at the outermost level, settings toolbar is invisible.

      Implementation:
      1. Verify ClaudeWatchApp.swift wraps MainView in NavigationStack
      2. Ensure toolbar items appear correctly
      3. Verify every view state has an escape path (exit button visible)

      Required pattern:
      ```swift
      // ClaudeWatchApp.swift
      WindowGroup {
          NavigationStack {
              MainView()  // Toolbar now visible
          }
      }
      ```

      If NavigationStack is missing, add it. This prevents users from getting
      stuck in demo mode or other states with no escape.
    priority: critical
    parallel_group: 14
    completed: true
    verification: |
      grep -q 'NavigationStack' ClaudeWatch/App/ClaudeWatchApp.swift && exit 0 || exit 1
    acceptance_criteria:
      - "NavigationStack wraps MainView in ClaudeWatchApp"
      - "Settings toolbar button visible in all states"
      - "Every state has an escape path"
    files:
      - "ClaudeWatch/App/ClaudeWatchApp.swift"
    tags:
      - navigation
      - critical-fix
      - toolbar
    commit_template: "fix(nav): Ensure NavigationStack at app root for toolbar visibility"
  - id: "UX17"
    title: "Add complete state reset for Exit Demo Mode"
    description: |
      CRITICAL LEARNING (from docs/solutions/ui-bugs/watchos-demo-mode-stuck-no-exit):
      Incomplete state reset leaves app stuck. Must reset ALL related variables.

      Implementation in WatchService.swift:
      ```swift
      // BUG: Incomplete reset
      func exitDemoMode() {
          isDemoMode = false
          state = WatchState()
          // Missing: connectionStatus, pairingId
      }

      // FIXED: Atomic complete reset
      func exitDemoMode() {
          isDemoMode = false
          state = WatchState()
          connectionStatus = .disconnected
          pairingId = ""  // Critical - enables PairingView
      }
      ```

      Also ensure StateViews.swift EmptyStateView has "Pair with Code" button when unpaired.
    priority: high
    parallel_group: 14
    completed: true
    verification: |
      grep -q 'exitDemoMode\|pairingId.*=.*""' ClaudeWatch/Services/WatchService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "exitDemoMode resets isDemoMode, state, connectionStatus, and pairingId"
      - "EmptyStateView shows Pair with Code when unpaired"
      - "Exit Demo Mode returns to PairingView correctly"
    files:
      - "ClaudeWatch/Services/WatchService.swift"
      - "ClaudeWatch/Views/StateViews.swift"
    tags:
      - state-management
      - critical-fix
      - recovery
    commit_template: "fix(state): Add complete state reset for Exit Demo Mode"
  # ═══════════════════════════════════════════════════════════════════════════
  # INFRASTRUCTURE: Ralph Parallel Execution
  # Parallel Group 15: Tooling improvements
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "INFRA1"
    title: "Implement parallel worker infrastructure for Ralph"
    description: |
      Implement the parallel execution system as specified in PARALLEL-IMPL-SPEC.md.

      Phase 1 - Create parallel infrastructure:
      1. Create .claude/ralph/parallel/ directory structure
      2. Create parallel-utils.sh with locking and queue functions
      3. Create ralph-worker.sh worker process script

      Phase 2 - Extend ralph.sh:
      1. Add --parallel, --max-workers, --parallel-group arguments
      2. Add run_parallel_loop() coordinator function
      3. Add worker spawning and shutdown logic

      Phase 3 - Add validation pipeline:
      1. Implement validate_parallel_batch() with syntax check
      2. Add merge_worktree_to_main() for git coordination
      3. Integrate with existing build verification

      Reference: .claude/ralph/PARALLEL-IMPL-SPEC.md
    priority: high
    parallel_group: 15
    completed: false
    verification: |
      [[ -f ".claude/ralph/parallel-utils.sh" ]] && \
      [[ -f ".claude/ralph/ralph-worker.sh" ]] && \
      grep -q 'parallel' .claude/ralph/ralph.sh && exit 0 || exit 1
    acceptance_criteria:
      - "parallel-utils.sh exists with locking functions"
      - "ralph-worker.sh exists and is executable"
      - "ralph.sh supports --parallel flag"
      - "Workers can claim and execute tasks"
    files:
      - ".claude/ralph/parallel-utils.sh"
      - ".claude/ralph/ralph-worker.sh"
      - ".claude/ralph/ralph.sh"
    tags:
      - infrastructure
      - parallel
      - tooling
    commit_template: "feat(ralph): Implement parallel worker execution system"
  - id: "INFRA2"
    title: "Add parallel thread visualization to monitor-ralph.sh"
    description: |
      Update monitor-ralph.sh to display parallel execution status with
      visual thread representation to help developers understand which
      tasks are grouped into which threads.

      Visualization requirements:
      1. Show 3 worker threads with status (idle/running/paused)
      2. Display current task ID and title for each active worker
      3. Show progress bar estimation for running tasks
      4. Visualize task queue grouped by parallel_group
      5. Show file locks held by each worker
      6. Use color coding: green=running, yellow=idle, red=stopped

      ASCII layout for parallel threads:
      ```
      ┌─────────────────────────────────────────────────────────┐
      │  WORKER THREADS                                          │
      ├─────────────────────────────────────────────────────────┤
      │  ▶ Thread 1 ─── UX3: Create StateViews.swift            │
      │              [████████████░░░░░░░░] 60%                  │
      │                                                          │
      │  ▶ Thread 2 ─── UX4: Create ActionViews.swift           │
      │              [██████░░░░░░░░░░░░░░] 30%                  │
      │                                                          │
      │  ○ Thread 3 ─── waiting for task...                      │
      └─────────────────────────────────────────────────────────┘

      TASK QUEUE BY PARALLEL GROUP
      ├─────────────────────────────────────────────────────────┤
      │  ✓ Group 10 [2/2] ───────────────────────────────────── │
      │    [UX1] [UX2]                                           │
      │                                                          │
      │  ► Group 11 [1/4] ───────────────────────────────────── │
      │    [UX3] [UX4] [UX5] [UX6]                               │
      │    └── Can run in parallel (no file conflicts)          │
      └─────────────────────────────────────────────────────────┘
      ```

      Reference: .claude/ralph/PARALLEL-IMPL-SPEC.md section 2.1
    priority: medium
    parallel_group: 15
    completed: false
    depends_on:
      - "INFRA1"
    verification: |
      grep -q 'show_parallel_threads\|WORKER THREADS' .claude/ralph/monitor-ralph.sh && exit 0 || exit 1
    acceptance_criteria:
      - "Monitor shows worker thread status visualization"
      - "Task queue displays by parallel_group"
      - "File locks are visible when held"
      - "Color coding matches status"
    files:
      - ".claude/ralph/monitor-ralph.sh"
    tags:
      - infrastructure
      - parallel
      - monitoring
      - visualization
    commit_template: "feat(ralph): Add parallel thread visualization to monitor"
  # ═══════════════════════════════════════════════════════════════════════════
  # iOS 26 / watchOS 13: Foundation Models & Liquid Glass
  # Parallel Group 16: Platform modernization
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "FM1"
    title: "Add Foundation Models availability check to WatchService"
    description: |
      Integrate Apple's on-device LLM (Foundation Models framework) for local
      AI processing without cloud dependency.

      Implementation:
      1. Import FoundationModels framework
      2. Add SystemLanguageModel.default availability check
      3. Create graceful fallback for unsupported devices
      4. Show download progress when .modelNotReady

      Reference: Read Apple's hidden docs first:
      /Applications/Xcode.app/Contents/PlugIns/IDEIntelligenceChat.framework/
        Versions/A/Resources/AdditionalDocumentation/
        FoundationModels-Using-on-device-LLM-in-your-app.md

      Use cases for Claude Watch:
      - Parse notifications locally without network
      - Summarize pending actions on-device
      - Voice command processing offline
      - Privacy-preserving action classification
    priority: medium
    parallel_group: 16
    completed: false
    verification: |
      grep -q 'FoundationModels\|SystemLanguageModel' ClaudeWatch/Services/WatchService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "FoundationModels imported in WatchService"
      - "Availability check implemented"
      - "Fallback UI for unsupported devices"
      - "Download progress shown when model not ready"
    files:
      - "ClaudeWatch/Services/WatchService.swift"
    tags:
      - ios26
      - foundation-models
      - on-device-ai
    commit_template: "feat(ai): Add Foundation Models availability check"
  - id: "FM2"
    title: "Create @Generable ApprovalRequest for structured parsing"
    description: |
      Use Foundation Models' @Generable macro for type-safe parsing of
      incoming Claude Code actions.

      Implementation:
      ```swift
      import FoundationModels

      @Generable(description: "Parsed approval request from Claude Code")
      struct ApprovalRequest {
          @Guide(description: "Action type", .options("file_edit", "command", "api_call"))
          var actionType: String

          @Guide(description: "Risk level 1-5", .range(1...5))
          var riskLevel: Int

          @Guide(description: "One sentence summary")
          var summary: String
      }
      ```

      Benefits:
      - Type-safe structured output from LLM
      - No manual JSON parsing
      - Automatic validation via @Guide constraints
      - Works with streaming via PartiallyGenerated
    priority: medium
    parallel_group: 16
    completed: false
    depends_on:
      - "FM1"
    verification: |
      grep -q '@Generable' ClaudeWatch/Models/*.swift && exit 0 || exit 1
    acceptance_criteria:
      - "@Generable struct defined for approval requests"
      - "@Guide annotations for all fields"
      - "Integration with LanguageModelSession"
    files:
      - "ClaudeWatch/Models/ApprovalRequest.swift"
    tags:
      - ios26
      - foundation-models
      - structured-generation
    commit_template: "feat(ai): Add @Generable ApprovalRequest for structured parsing"
  - id: "LG1"
    title: "Adopt Liquid Glass design for main UI"
    description: |
      Replace custom materials with iOS 26 Liquid Glass for native feel.

      Implementation:
      1. Replace .background(.regularMaterial) with .glassEffect()
      2. Use .buttonStyle(.glass) for action buttons
      3. Use .buttonStyle(.glassProminent) for primary actions
      4. Wrap related views in GlassEffectContainer
      5. Add .interactive() for touch-responsive glass

      Reference: Read Apple's hidden docs:
      /Applications/Xcode.app/Contents/PlugIns/IDEIntelligenceChat.framework/
        Versions/A/Resources/AdditionalDocumentation/
        SwiftUI-Implementing-Liquid-Glass-Design.md

      Key patterns:
      ```swift
      // Before
      Text("Status").background(.regularMaterial)

      // After
      Text("Status").glassEffect(.regular.interactive())
      ```
    priority: medium
    parallel_group: 16
    completed: false
    verification: |
      grep -rq 'glassEffect\|buttonStyle(.glass' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "Main views use .glassEffect()"
      - "Buttons use .glass or .glassProminent style"
      - "GlassEffectContainer wraps related views"
      - "Interactive glass for touch elements"
    files:
      - "ClaudeWatch/Views/MainView.swift"
      - "ClaudeWatch/Views/ActionViews.swift"
      - "ClaudeWatch/Views/StateViews.swift"
    tags:
      - ios26
      - liquid-glass
      - design
    commit_template: "feat(ui): Adopt Liquid Glass design language"
  - id: "LG2"
    title: "Add glass morphing transitions between states"
    description: |
      Implement smooth morphing transitions using Liquid Glass namespace.

      Implementation:
      1. Create @Namespace for glass effects
      2. Add glassEffectID to stateful views
      3. Use GlassEffectContainer for morphing context
      4. Animate state changes with .animation()

      Pattern:
      ```swift
      @Namespace private var glassNamespace

      GlassEffectContainer {
          switch state {
          case .idle:
              IdleView()
                  .glassEffect()
                  .glassEffectID("main", in: glassNamespace)
          case .pending:
              PendingView()
                  .glassEffect()
                  .glassEffectID("main", in: glassNamespace)
          }
      }
      .animation(.spring, value: state)
      ```
    priority: low
    parallel_group: 16
    completed: false
    depends_on:
      - "LG1"
    verification: |
      grep -rq 'glassEffectID\|@Namespace.*glass' ClaudeWatch/Views/ && exit 0 || exit 1
    acceptance_criteria:
      - "@Namespace defined for glass morphing"
      - "glassEffectID on state views"
      - "Smooth morphing between states"
    files:
      - "ClaudeWatch/Views/MainView.swift"
    tags:
      - ios26
      - liquid-glass
      - animation
    commit_template: "feat(ui): Add glass morphing transitions"

  # ═══════════════════════════════════════════════════════════════════════════
  # META: Ralph System Improvements
  # Parallel Group 17: Self-improvement
  # ═══════════════════════════════════════════════════════════════════════════
  - id: "META1"
    title: "Implement progressive disclosure in PROMPT.md"
    description: |
      Refactor PROMPT.md to use progressive disclosure pattern to reduce
      token pollution.

      Current problem:
      - Entire PROMPT.md loads for every task (~300 lines)
      - Much content is irrelevant to specific task types
      - Wastes tokens on context that won't be used

      Solution - Modular prompt structure:
      ```
      PROMPT.md (core, always loaded)
        ├── PROMPT-swift.md (loaded for Swift tasks)
        ├── PROMPT-ui.md (loaded for UI tasks)
        ├── PROMPT-testing.md (loaded for test tasks)
        └── PROMPT-infra.md (loaded for infrastructure tasks)
      ```

      Implementation:
      1. Extract task-type-specific content to separate files
      2. Add task type detection in ralph.sh
      3. Concatenate only relevant prompt modules
      4. Keep core PROMPT.md under 100 lines

      Pattern: "You do not want to pollute your token system...
      have it much like in a disclosure way"
    priority: medium
    parallel_group: 17
    completed: false
    verification: |
      [[ -f ".claude/ralph/PROMPT-swift.md" ]] || [[ $(wc -l < .claude/ralph/PROMPT.md) -lt 150 ]] && exit 0 || exit 1
    acceptance_criteria:
      - "PROMPT.md core under 150 lines"
      - "Task-type-specific content in separate files"
      - "ralph.sh detects task type and loads relevant modules"
    files:
      - ".claude/ralph/PROMPT.md"
      - ".claude/ralph/ralph.sh"
    tags:
      - meta
      - token-efficiency
      - progressive-disclosure
    commit_template: "refactor(ralph): Implement progressive disclosure in prompts"

  - id: "META2"
    title: "Add automatic skill harvesting to Ralph"
    description: |
      After successful task completion, automatically analyze the session
      to extract reusable patterns into skills.

      Implementation:
      1. Capture session transcript (already in progress log)
      2. After task completion, run skill extraction prompt
      3. If pattern is harvestable, create skill file
      4. Log harvested skills in metrics.json

      Criteria for harvesting:
      - Non-trivial solution (not simple typo/config)
      - Applies to multiple situations
      - Contains non-obvious insight

      Pattern: "Use conversation history to get Claude to review it
      and suggest to make skills file... turn that into a skill immediately"
    priority: low
    parallel_group: 17
    completed: false
    depends_on:
      - "META1"
    verification: |
      grep -q 'harvest_skill\|skill_extraction' .claude/ralph/ralph.sh && exit 0 || exit 1
    acceptance_criteria:
      - "Session transcript captured after each task"
      - "Skill extraction runs on successful completion"
      - "Harvested skills saved to .claude/commands/"
    files:
      - ".claude/ralph/ralph.sh"
    tags:
      - meta
      - skill-harvesting
      - automation
    commit_template: "feat(ralph): Add automatic skill harvesting"

  # ═══════════════════════════════════════════════════════════════════════════
  # PHASE 8: CARPLAY CLAUDE - iOS Companion App & CarPlay Integration
  # From: docs/CARPLAY_MVP_SPEC.md
  # Parallel Groups 20-23
  #
  # VISION: "Start Claude Code in terminal, scan QR, control from Watch/Car/Phone"
  # KEY FEATURES:
  # - Steering wheel buttons: ◀◀ reject, ▶▶ approve
  # - Voice interaction via Siri/call button
  # - Audio summaries of pending approvals
  # - Now Playing-style UI for quick glances
  # - Shared pairing with Watch via iOS companion app
  # ═══════════════════════════════════════════════════════════════════════════

  # --- Phase 8.1: iOS Companion App Foundation (parallel_group: 20) ---
  - id: "CP1"
    title: "Create iOS companion app project with App Groups"
    description: |
      Create the ClaudeMobile iOS app project that serves as the companion
      for both Apple Watch and CarPlay interfaces.

      Implementation:
      1. Create ClaudeMobile/ directory structure:
         - App/, Scenes/, Views/, Services/, Intents/, Resources/
      2. Create ClaudeMobile.xcodeproj with:
         - iOS deployment target: 17.0
         - App Group: group.com.claudewatch.shared
         - CarPlay entitlement: com.apple.developer.carplay-driving-task
      3. Create ClaudeMobileApp.swift @main entry point
      4. Create AppDelegate.swift for push notification handling
      5. Configure Info.plist with required keys:
         - NSCameraUsageDescription (QR scanning)
         - NSSiriUsageDescription (voice control)
         - UIBackgroundModes (audio, remote-notification, voip)
         - UIApplicationSceneManifest (CarPlay scene config)

      File structure:
      ```
      ClaudeMobile/
      ├── App/
      │   ├── ClaudeMobileApp.swift
      │   └── AppDelegate.swift
      ├── Scenes/
      │   ├── CarPlay/
      │   └── Phone/
      ├── Views/
      ├── Services/
      ├── Intents/
      └── Resources/
      ```
    priority: critical
    parallel_group: 20
    completed: false
    verification: |
      [ -d "ClaudeMobile" ] && \
      [ -f "ClaudeMobile/App/ClaudeMobileApp.swift" ] && \
      [ -f "ClaudeMobile/App/AppDelegate.swift" ] && exit 0 || exit 1
    acceptance_criteria:
      - "ClaudeMobile directory structure created"
      - "Xcode project with App Groups entitlement"
      - "CarPlay entitlement configured"
      - "Info.plist with all required keys"
      - "Basic app launches in simulator"
    files:
      - "ClaudeMobile/App/ClaudeMobileApp.swift"
      - "ClaudeMobile/App/AppDelegate.swift"
      - "ClaudeMobile/Info.plist"
      - "ClaudeMobile/ClaudeMobile.entitlements"
    tags:
      - carplay
      - ios
      - project-setup
      - foundation
    commit_template: "feat(carplay): Create iOS companion app project"

  - id: "CP2"
    title: "Implement QR scanner view for pairing"
    description: |
      Create QRScannerView using AVFoundation for camera-based QR code pairing.
      This enables faster pairing than manual code entry.

      Implementation:
      1. Create ClaudeMobile/Views/QRScannerView.swift
      2. Create QRScanner ObservableObject with:
         - AVCaptureSession management
         - AVCaptureMetadataOutput for QR detection
         - scannedCode published property
      3. Create CameraPreviewView UIViewRepresentable
      4. Implement QR code URL parsing:
         - Scheme: claude-watch://
         - Host: pair
         - Query: code=ABC-123&server=wss://...
      5. Add viewfinder overlay with scanning animation
      6. Add "Enter Code Manually" fallback button

      QR URL format:
      ```
      claude-watch://pair?code=ABC-123&server=wss://claude-watch.fotescodev.workers.dev
      ```

      Pattern for handling scan:
      ```swift
      private func handleScannedCode(_ code: String) {
          guard let url = URL(string: code),
                url.scheme == "claude-watch",
                url.host == "pair",
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false),
                let pairingCode = components.queryItems?.first(where: { $0.name == "code" })?.value
          else { return }

          Task {
              try await SharedService.shared.completePairing(code: pairingCode)
          }
      }
      ```
    priority: critical
    parallel_group: 20
    completed: false
    verification: |
      [ -f "ClaudeMobile/Views/QRScannerView.swift" ] && \
      grep -q 'AVCaptureSession\|AVCaptureMetadataOutput' ClaudeMobile/Views/QRScannerView.swift && \
      grep -q 'claude-watch://pair' ClaudeMobile/Views/QRScannerView.swift && exit 0 || exit 1
    acceptance_criteria:
      - "QRScannerView with camera preview"
      - "QR code detection via AVCaptureMetadataOutput"
      - "URL parsing for claude-watch:// scheme"
      - "Viewfinder overlay with visual feedback"
      - "Manual entry fallback button"
    files:
      - "ClaudeMobile/Views/QRScannerView.swift"
    tags:
      - carplay
      - pairing
      - camera
      - qr-code
    commit_template: "feat(carplay): Implement QR scanner for pairing"

  - id: "CP3"
    title: "Create SharedService for App Group state sync"
    description: |
      Create SharedService that manages state shared between Watch, iPhone,
      and CarPlay via App Groups.

      Implementation:
      1. Create ClaudeMobile/Services/SharedService.swift
      2. Create Shared/Models/SharedModels.swift with:
         - SharedPairingState (pairingId, cloudServerURL, deviceToken, etc.)
         - PendingAction with RiskLevel enum
         - SessionState
         - ConnectionStatus
      3. SharedService singleton with:
         - UserDefaults(suiteName: "group.com.claudewatch.shared")
         - @Published state properties
         - completePairing(code:) async throws
         - respondToRequest(requestId:, approved:) async throws
         - Cloud polling for pending requests
      4. Port patterns from WatchService.swift:
         - Connection management
         - Message queue
         - Error handling

      Key patterns from WatchService to reuse:
      - ReconnectionConfig for exponential backoff
      - QueuedMessage for reliable delivery
      - Cloud polling with pollingInterval
    priority: critical
    parallel_group: 20
    completed: false
    depends_on:
      - "CP1"
    verification: |
      [ -f "ClaudeMobile/Services/SharedService.swift" ] && \
      grep -q 'group.com.claudewatch' ClaudeMobile/Services/SharedService.swift && \
      grep -q 'completePairing\|pairingId' ClaudeMobile/Services/SharedService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "SharedService with App Group UserDefaults"
      - "SharedPairingState Codable struct"
      - "Cloud pairing API integration"
      - "State sync across Watch/Phone/CarPlay"
      - "Patterns ported from WatchService"
    files:
      - "ClaudeMobile/Services/SharedService.swift"
      - "Shared/Models/SharedModels.swift"
    tags:
      - carplay
      - state-management
      - app-groups
      - shared
    commit_template: "feat(carplay): Create SharedService for App Group sync"

  - id: "CP4"
    title: "Implement iOS companion app views (Home, Settings, Pairing)"
    description: |
      Create the main views for the iOS companion app.

      Implementation:
      1. Create ClaudeMobile/Views/HomeView.swift:
         - Connection status indicator
         - Current task display
         - Pending actions count
         - Quick actions (Approve All, Settings)
      2. Create ClaudeMobile/Views/PairingView.swift:
         - Code input TextField
         - QR scan button
         - Validation feedback
      3. Create ClaudeMobile/Views/SettingsView.swift:
         - Server URL configuration
         - Audio preferences
         - Unpair button
         - Watch/CarPlay status
      4. Create ClaudeMobile/Views/ApprovalListView.swift:
         - List of pending approvals
         - Swipe to approve/reject
         - Detail expansion

      Navigation structure:
      ```swift
      NavigationStack {
          HomeView()
              .sheet(isPresented: $showPairing) {
                  QRScannerView()
              }
              .sheet(isPresented: $showSettings) {
                  SettingsView()
              }
      }
      ```
    priority: high
    parallel_group: 20
    completed: false
    depends_on:
      - "CP3"
    verification: |
      [ -f "ClaudeMobile/Views/HomeView.swift" ] && \
      [ -f "ClaudeMobile/Views/SettingsView.swift" ] && \
      [ -f "ClaudeMobile/Views/ApprovalListView.swift" ] && exit 0 || exit 1
    acceptance_criteria:
      - "HomeView with status and quick actions"
      - "PairingView with code input and QR button"
      - "SettingsView with all configuration options"
      - "ApprovalListView with swipe actions"
      - "NavigationStack-based navigation"
    files:
      - "ClaudeMobile/Views/HomeView.swift"
      - "ClaudeMobile/Views/PairingView.swift"
      - "ClaudeMobile/Views/SettingsView.swift"
      - "ClaudeMobile/Views/ApprovalListView.swift"
    tags:
      - carplay
      - ios
      - swiftui
      - views
    commit_template: "feat(carplay): Implement iOS companion app views"

  - id: "CP5"
    title: "Add push notification handling for iOS app"
    description: |
      Implement push notification registration and handling for the iOS app.

      Implementation:
      1. Update AppDelegate.swift:
         - UNUserNotificationCenter delegate
         - registerForRemoteNotifications()
         - didRegisterForRemoteNotifications(withDeviceToken:)
      2. Create notification categories:
         - CLAUDE_ACTION with Approve/Reject/ApproveAll actions
      3. Handle notification responses:
         - APPROVE_ACTION
         - REJECT_ACTION
         - APPROVE_ALL_ACTION
      4. Store device token in SharedService for cloud pairing
      5. Handle foreground notification presentation

      Pattern (from watchOS AppDelegate):
      ```swift
      func userNotificationCenter(
          _ center: UNUserNotificationCenter,
          didReceive response: UNNotificationResponse,
          withCompletionHandler completionHandler: @escaping () -> Void
      ) {
          let requestId = response.notification.request.content.userInfo["requestId"] as? String
          switch response.actionIdentifier {
          case "APPROVE_ACTION":
              Task { try? await SharedService.shared.respondToRequest(requestId!, approved: true) }
          case "REJECT_ACTION":
              Task { try? await SharedService.shared.respondToRequest(requestId!, approved: false) }
          default: break
          }
          completionHandler()
      }
      ```
    priority: high
    parallel_group: 20
    completed: false
    depends_on:
      - "CP3"
    verification: |
      grep -q 'UNUserNotificationCenter\|registerForRemoteNotifications' ClaudeMobile/App/AppDelegate.swift && \
      grep -q 'CLAUDE_ACTION\|APPROVE_ACTION' ClaudeMobile/App/AppDelegate.swift && exit 0 || exit 1
    acceptance_criteria:
      - "Push notification registration"
      - "Notification categories with actions"
      - "Action handlers for approve/reject"
      - "Device token storage in SharedService"
      - "Foreground notification display"
    files:
      - "ClaudeMobile/App/AppDelegate.swift"
    tags:
      - carplay
      - notifications
      - apns
      - ios
    commit_template: "feat(carplay): Add push notification handling"

  # --- Phase 8.2: CarPlay Integration (parallel_group: 21) ---
  - id: "CP6"
    title: "Create CarPlay scene delegate"
    description: |
      Implement CarPlaySceneDelegate for CarPlay lifecycle management.

      Implementation:
      1. Create ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift
      2. Implement CPTemplateApplicationSceneDelegate:
         - templateApplicationScene(_:didConnect:)
         - templateApplicationScene(_:didDisconnect:)
      3. Store interfaceController reference
      4. Set up root template (CPTabBarTemplate or CPNowPlayingTemplate)
      5. Handle CarPlay connection/disconnection events
      6. Update SharedService.carPlayActive state

      CarPlay scene configuration (Info.plist):
      ```xml
      <key>CPTemplateApplicationSceneSessionRoleApplication</key>
      <array>
          <dict>
              <key>UISceneClassName</key>
              <string>CPTemplateApplicationScene</string>
              <key>UISceneDelegateClassName</key>
              <string>$(PRODUCT_MODULE_NAME).CarPlaySceneDelegate</string>
              <key>UISceneConfigurationName</key>
              <string>CarPlay</string>
          </dict>
      </array>
      ```
    priority: critical
    parallel_group: 21
    completed: false
    depends_on:
      - "CP1"
      - "CP3"
    verification: |
      [ -f "ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift" ] && \
      grep -q 'CPTemplateApplicationSceneDelegate\|didConnect.*interfaceController' ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift && exit 0 || exit 1
    acceptance_criteria:
      - "CarPlaySceneDelegate implements CPTemplateApplicationSceneDelegate"
      - "Handles didConnect/didDisconnect lifecycle"
      - "Sets up root template on connection"
      - "Updates SharedService.carPlayActive"
      - "Info.plist scene configuration correct"
    files:
      - "ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift"
      - "ClaudeMobile/Info.plist"
    tags:
      - carplay
      - scene-delegate
      - lifecycle
    commit_template: "feat(carplay): Create CarPlay scene delegate"

  - id: "CP7"
    title: "Implement CPNowPlayingTemplate for approval queue"
    description: |
      Create the primary CarPlay UI using CPNowPlayingTemplate to display
      pending approvals as "tracks" in a media player-like interface.

      Implementation:
      1. Create ClaudeMobile/Scenes/CarPlay/CarPlayService.swift
      2. Create NowPlayingInfo struct for display state
      3. Implement MPNowPlayingInfoCenter updates:
         - MPMediaItemPropertyTitle: Action title
         - MPMediaItemPropertyArtist: "Claude Code"
         - MPMediaItemPropertyAlbumTitle: Task name
         - MPNowPlayingInfoPropertyPlaybackQueueIndex: Current index
         - MPNowPlayingInfoPropertyPlaybackQueueCount: Total pending
      4. Create artwork images for action types (file_edit, bash, etc.)
      5. Add CPNowPlayingTemplate to interface controller
      6. Update display when pending actions change

      Pattern:
      ```swift
      func updateNowPlayingInfo() {
          guard let action = currentAction else { return }
          var info = [String: Any]()
          info[MPMediaItemPropertyTitle] = action.title
          info[MPMediaItemPropertyArtist] = "Claude Code"
          info[MPMediaItemPropertyAlbumTitle] = state.taskName
          info[MPNowPlayingInfoPropertyPlaybackQueueIndex] = currentIndex
          info[MPNowPlayingInfoPropertyPlaybackQueueCount] = state.pendingActions.count
          MPNowPlayingInfoCenter.default().nowPlayingInfo = info
      }
      ```
    priority: critical
    parallel_group: 21
    completed: false
    depends_on:
      - "CP6"
    verification: |
      [ -f "ClaudeMobile/Scenes/CarPlay/CarPlayService.swift" ] && \
      grep -q 'MPNowPlayingInfoCenter\|NowPlayingInfo' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && \
      grep -q 'CPNowPlayingTemplate' ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift && exit 0 || exit 1
    acceptance_criteria:
      - "CarPlayService manages Now Playing state"
      - "NowPlayingInfo struct with all display fields"
      - "MPNowPlayingInfoCenter updates on state change"
      - "Action type artwork images"
      - "Queue index/count display"
    files:
      - "ClaudeMobile/Scenes/CarPlay/CarPlayService.swift"
      - "ClaudeMobile/Scenes/CarPlay/CarPlaySceneDelegate.swift"
    tags:
      - carplay
      - now-playing
      - media-player
    commit_template: "feat(carplay): Implement CPNowPlayingTemplate"

  - id: "CP8"
    title: "Configure MPRemoteCommandCenter for steering wheel controls"
    description: |
      Set up MPRemoteCommandCenter to handle steering wheel button presses
      for approve (▶▶), reject (◀◀), and narration toggle (▶️).

      Implementation:
      1. Add to CarPlayService.swift:
         - configureRemoteCommands()
         - handleNextTrackCommand() -> approve
         - handlePreviousTrackCommand() -> reject
         - handleTogglePlayPauseCommand() -> narration
      2. Enable required commands:
         - nextTrackCommand (▶▶ = approve)
         - previousTrackCommand (◀◀ = reject)
         - togglePlayPauseCommand (▶️ = narration)
      3. Return appropriate MPRemoteCommandHandlerStatus
      4. Call SharedService for approve/reject actions
      5. Update Now Playing info after each action

      Implementation:
      ```swift
      func configureRemoteCommands() {
          let commandCenter = MPRemoteCommandCenter.shared()

          commandCenter.nextTrackCommand.isEnabled = true
          commandCenter.nextTrackCommand.addTarget { [weak self] _ in
              guard let action = self?.currentAction else {
                  return .noActionableNowPlayingItem
              }
              Task {
                  try? await SharedService.shared.respondToRequest(action.id, approved: true)
              }
              self?.playAudioFeedback(.approved)
              return .success
          }

          commandCenter.previousTrackCommand.isEnabled = true
          commandCenter.previousTrackCommand.addTarget { [weak self] _ in
              guard let action = self?.currentAction else {
                  return .noActionableNowPlayingItem
              }
              Task {
                  try? await SharedService.shared.respondToRequest(action.id, approved: false)
              }
              self?.playAudioFeedback(.rejected)
              return .success
          }
      }
      ```
    priority: critical
    parallel_group: 21
    completed: false
    depends_on:
      - "CP7"
    verification: |
      grep -q 'MPRemoteCommandCenter' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && \
      grep -q 'nextTrackCommand\|previousTrackCommand' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && \
      grep -q 'togglePlayPauseCommand' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "MPRemoteCommandCenter configured"
      - "nextTrackCommand -> approve action"
      - "previousTrackCommand -> reject action"
      - "togglePlayPauseCommand -> toggle narration"
      - "Proper return values for all commands"
    files:
      - "ClaudeMobile/Scenes/CarPlay/CarPlayService.swift"
    tags:
      - carplay
      - steering-wheel
      - remote-commands
      - critical
    commit_template: "feat(carplay): Configure steering wheel controls"

  - id: "CP9"
    title: "Add audio feedback system for CarPlay"
    description: |
      Create AudioService for audio cues and feedback tones in CarPlay.

      Implementation:
      1. Create ClaudeMobile/Services/AudioService.swift
      2. Define AudioCue enum:
         - newApproval, approved, rejected, allComplete
         - connectionLost, voicePromptStart, voicePromptEnd
      3. Load audio files from Resources/:
         - approved.wav, rejected.wav, chime.wav, warning.wav
      4. Create AVAudioPlayer instances for each cue
      5. Configure audio session for CarPlay:
         - AVAudioSession.Category.playback
         - AVAudioSession.Mode.default
      6. Play appropriate cue on events

      Audio cue pattern:
      ```swift
      enum AudioCue {
          case newApproval      // chime
          case approved         // success tone
          case rejected         // distinct tone
          case allComplete      // happy chime
          case connectionLost   // warning tone
      }

      class AudioService {
          static let shared = AudioService()
          private var players: [AudioCue: AVAudioPlayer] = [:]

          func playFeedback(_ cue: AudioCue) {
              players[cue]?.play()
          }
      }
      ```
    priority: high
    parallel_group: 21
    completed: false
    depends_on:
      - "CP7"
    verification: |
      [ -f "ClaudeMobile/Services/AudioService.swift" ] && \
      grep -q 'AVAudioPlayer\|AudioCue' ClaudeMobile/Services/AudioService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "AudioService with audio cue playback"
      - "AudioCue enum with all event types"
      - "Audio session configured for CarPlay"
      - "Sound files in Resources/"
      - "Plays on approve/reject events"
    files:
      - "ClaudeMobile/Services/AudioService.swift"
      - "ClaudeMobile/Resources/"
    tags:
      - carplay
      - audio
      - feedback
    commit_template: "feat(carplay): Add audio feedback system"

  - id: "CP10"
    title: "Add connection status display for CarPlay"
    description: |
      Display connection status in CarPlay UI and handle disconnection gracefully.

      Implementation:
      1. Add connection status to Now Playing subtitle
      2. Show CPAlertTemplate on connection loss
      3. Add reconnection UI with progress
      4. Update MPNowPlayingInfo with status:
         - Connected: Show pending count
         - Disconnected: Show "Offline" in subtitle
         - Reconnecting: Show "Reconnecting..." with attempt count
      5. Audio cue on connection change

      Pattern:
      ```swift
      func updateConnectionStatus(_ status: ConnectionStatus) {
          switch status {
          case .connected:
              // Update subtitle to show pending count
          case .disconnected:
              showDisconnectedAlert()
              audioService.playFeedback(.connectionLost)
          case .reconnecting(let attempt):
              // Update subtitle with reconnection status
          }
      }
      ```
    priority: medium
    parallel_group: 21
    completed: false
    depends_on:
      - "CP7"
      - "CP9"
    verification: |
      grep -q 'ConnectionStatus\|connectionLost\|Offline\|Reconnecting' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "Connection status in Now Playing subtitle"
      - "Alert on connection loss"
      - "Reconnection progress display"
      - "Audio cue on status change"
    files:
      - "ClaudeMobile/Scenes/CarPlay/CarPlayService.swift"
    tags:
      - carplay
      - connection
      - status
    commit_template: "feat(carplay): Add connection status display"

  # --- Phase 8.3: Voice & Audio Narration (parallel_group: 22) ---
  - id: "CP11"
    title: "Implement AVSpeechSynthesizer narration"
    description: |
      Add text-to-speech narration for pending actions using AVSpeechSynthesizer.

      Implementation:
      1. Create ClaudeMobile/Services/NarrationService.swift
      2. Build narration text based on action type:
         - file_edit: "Claude wants to edit {title}. {description}..."
         - file_create: "Claude wants to create {title}..."
         - bash: "Claude wants to run command: {command}..."
      3. Configure AVSpeechUtterance:
         - Voice: AVSpeechSynthesisVoice(language: "en-US")
         - Rate: 0.52 (slightly faster than default)
      4. Add auto-narration on new approval (configurable)
      5. Play/Pause toggle via togglePlayPauseCommand

      Pattern:
      ```swift
      class NarrationService {
          private let synthesizer = AVSpeechSynthesizer()

          func narrateAction(_ action: PendingAction) {
              let text = buildNarration(action)
              let utterance = AVSpeechUtterance(string: text)
              utterance.voice = AVSpeechSynthesisVoice(language: "en-US")
              utterance.rate = 0.52
              synthesizer.speak(utterance)
          }

          private func buildNarration(_ action: PendingAction) -> String {
              switch action.type {
              case .fileEdit:
                  return "Claude wants to edit \(action.title). \(action.description). Press next to approve or previous to reject."
              // ... other cases
              }
          }
      }
      ```
    priority: high
    parallel_group: 22
    completed: false
    depends_on:
      - "CP7"
    verification: |
      [ -f "ClaudeMobile/Services/NarrationService.swift" ] && \
      grep -q 'AVSpeechSynthesizer\|AVSpeechUtterance' ClaudeMobile/Services/NarrationService.swift && \
      grep -q 'buildNarration\|narrateAction' ClaudeMobile/Services/NarrationService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "NarrationService with AVSpeechSynthesizer"
      - "Action-specific narration text"
      - "Configurable voice and rate"
      - "Auto-narration on new approvals"
      - "Toggle via play/pause command"
    files:
      - "ClaudeMobile/Services/NarrationService.swift"
    tags:
      - carplay
      - voice
      - tts
      - narration
    commit_template: "feat(carplay): Implement TTS narration"

  - id: "CP12"
    title: "Create SiriKit intents for voice control"
    description: |
      Define SiriKit intents for hands-free voice control of Claude Code.

      Implementation:
      1. Create ClaudeMobile/Intents/Intents.intentdefinition:
         - ClaudeApproveIntent: "Approve Claude"
         - ClaudeRejectIntent: "Reject Claude"
         - ClaudeStatusIntent: "What's Claude doing?"
         - ClaudeApproveAllIntent: "Approve all Claude changes"
         - ClaudeTalkIntent: "Tell Claude [message]"
      2. Create IntentHandler.swift extension:
         - Handle each intent type
         - Call SharedService for actions
         - Return appropriate response phrases
      3. Configure Siri capability in entitlements
      4. Add NSSiriUsageDescription to Info.plist

      Intent definition pattern:
      ```swift
      class IntentHandler: INExtension, ClaudeApproveIntentHandling {
          func handle(intent: ClaudeApproveIntent) async -> ClaudeApproveIntentResponse {
              guard let action = SharedService.shared.state.pendingActions.first else {
                  return ClaudeApproveIntentResponse(code: .failure, userActivity: nil)
              }
              try? await SharedService.shared.respondToRequest(action.id, approved: true)
              return ClaudeApproveIntentResponse.success(actionTitle: action.title)
          }
      }
      ```
    priority: high
    parallel_group: 22
    completed: false
    depends_on:
      - "CP3"
    verification: |
      [ -f "ClaudeMobile/Intents/Intents.intentdefinition" ] || \
      [ -f "ClaudeMobile/Intents/IntentHandler.swift" ] && \
      grep -q 'ClaudeApproveIntent\|INExtension' ClaudeMobile/Intents/IntentHandler.swift && exit 0 || exit 1
    acceptance_criteria:
      - "Intents.intentdefinition with all intents"
      - "IntentHandler implements all handlers"
      - "Siri entitlement configured"
      - "Response phrases for success/failure"
      - "Integration with SharedService"
    files:
      - "ClaudeMobile/Intents/Intents.intentdefinition"
      - "ClaudeMobile/Intents/IntentHandler.swift"
      - "ClaudeMobile/ClaudeMobile.entitlements"
    tags:
      - carplay
      - siri
      - voice
      - intents
    commit_template: "feat(carplay): Create SiriKit intents"

  - id: "CP13"
    title: "Add narration preferences to settings"
    description: |
      Add user-configurable audio/narration preferences.

      Implementation:
      1. Create AudioPreferences struct in SharedModels:
         - narrationEnabled: Bool
         - narrationSpeed: Float (0.5-2.0)
         - soundEffectsEnabled: Bool
         - autoNarrateNewApprovals: Bool
         - voiceId: String
      2. Add preferences UI to SettingsView:
         - Toggle for narration
         - Slider for speed
         - Toggle for sound effects
         - Toggle for auto-narrate
         - Voice picker
      3. Store in App Group UserDefaults
      4. Apply preferences in NarrationService and AudioService

      Pattern:
      ```swift
      struct AudioPreferences: Codable {
          var narrationEnabled: Bool = true
          var narrationSpeed: Float = 1.0
          var soundEffectsEnabled: Bool = true
          var autoNarrateNewApprovals: Bool = true
          var voiceId: String = "com.apple.voice.compact.en-US.Samantha"
      }
      ```
    priority: medium
    parallel_group: 22
    completed: false
    depends_on:
      - "CP4"
      - "CP11"
    verification: |
      grep -q 'AudioPreferences\|narrationEnabled\|narrationSpeed' Shared/Models/SharedModels.swift && \
      grep -q 'narrationEnabled\|audioPreferences' ClaudeMobile/Views/SettingsView.swift && exit 0 || exit 1
    acceptance_criteria:
      - "AudioPreferences Codable struct"
      - "Settings UI for all preferences"
      - "Preferences stored in App Group"
      - "Applied in NarrationService"
      - "Applied in AudioService"
    files:
      - "Shared/Models/SharedModels.swift"
      - "ClaudeMobile/Views/SettingsView.swift"
      - "ClaudeMobile/Services/NarrationService.swift"
      - "ClaudeMobile/Services/AudioService.swift"
    tags:
      - carplay
      - settings
      - preferences
      - audio
    commit_template: "feat(carplay): Add narration preferences"

  # --- Phase 8.4: API & Server Extensions (parallel_group: 22) ---
  - id: "CP14"
    title: "Add risk assessment to MCP server"
    description: |
      Add watch_assess_risk MCP tool to evaluate action risk level for CarPlay.

      Implementation:
      1. Add to MCPServer/server.py:
         - "watch_assess_risk" tool definition
         - _handle_assess_risk handler
      2. Risk assessment logic:
         - High: is_destructive OR lines_changed > 100 OR sensitive file
         - Medium: lines_changed > 20
         - Low: small, safe changes
      3. Sensitive file patterns:
         - .env, credentials, secret, key, password
      4. Return risk_level and reason

      Implementation:
      ```python
      "watch_assess_risk": {
          "description": "Assess risk level for CarPlay display",
          "parameters": {
              "action_type": {"type": "string"},
              "file_path": {"type": "string"},
              "lines_changed": {"type": "integer"},
              "is_destructive": {"type": "boolean"},
          },
          "handler": self._handle_assess_risk
      }

      async def _handle_assess_risk(self, action_type, file_path, lines_changed, is_destructive):
          if is_destructive or lines_changed > 100:
              return {"risk_level": "high", "reason": "Large or destructive change"}
          sensitive_patterns = [".env", "credentials", "secret", "key", "password"]
          if any(p in file_path.lower() for p in sensitive_patterns):
              return {"risk_level": "high", "reason": "Sensitive file"}
          if lines_changed > 20:
              return {"risk_level": "medium", "reason": "Moderate change"}
          return {"risk_level": "low", "reason": "Small, safe change"}
      ```
    priority: medium
    parallel_group: 22
    completed: false
    verification: |
      grep -q 'watch_assess_risk\|_handle_assess_risk' MCPServer/server.py && \
      grep -q 'risk_level' MCPServer/server.py && exit 0 || exit 1
    acceptance_criteria:
      - "watch_assess_risk MCP tool defined"
      - "Risk levels: high, medium, low"
      - "Sensitive file detection"
      - "Destructive operation detection"
      - "Returns risk_level and reason"
    files:
      - "MCPServer/server.py"
    tags:
      - carplay
      - server
      - mcp
      - risk-assessment
    commit_template: "feat(api): Add risk assessment MCP tool"

  - id: "CP15"
    title: "Add voice prompt API endpoints to cloud relay"
    description: |
      Add API endpoints for voice prompt flow to cloud relay worker.

      Implementation:
      1. Add POST /voice/prompt endpoint:
         - Body: { pairingId, text, source: "carplay" }
         - Store prompt in KV with promptId
         - Forward to Claude Code via WebSocket
         - Return: { success, promptId }
      2. Add GET /voice/response/{promptId} endpoint:
         - Poll for Claude's response
         - Return: { status: "pending|complete", response }
      3. Add voice prompt forwarding in WebSocket handler
      4. Add 30-second TTL for prompt/response KV entries

      Pattern:
      ```javascript
      // POST /voice/prompt
      async function handleVoicePrompt(request, env) {
          const { pairingId, text, source } = await request.json();
          const promptId = crypto.randomUUID().slice(0, 8);

          // Store prompt
          await env.KV.put(`prompt:${promptId}`, JSON.stringify({ text, source }), { expirationTtl: 30 });

          // Forward to Claude Code (if connected)
          // ...

          return Response.json({ success: true, promptId });
      }
      ```
    priority: low
    parallel_group: 22
    completed: false
    verification: |
      grep -q '/voice/prompt\|/voice/response' MCPServer/worker/src/index.js && exit 0 || exit 1
    acceptance_criteria:
      - "POST /voice/prompt endpoint"
      - "GET /voice/response/{promptId} endpoint"
      - "Prompt forwarding to Claude Code"
      - "TTL on prompt/response entries"
    files:
      - "MCPServer/worker/src/index.js"
    tags:
      - carplay
      - server
      - api
      - voice
    commit_template: "feat(api): Add voice prompt endpoints"

  # --- Phase 8.5: Testing & Polish (parallel_group: 23) ---
  - id: "CP16"
    title: "Add CarPlay unit tests"
    description: |
      Create unit tests for CarPlay functionality.

      Implementation:
      1. Create ClaudeMobile/Tests/CarPlayServiceTests.swift:
         - testSteeringWheelApprove()
         - testSteeringWheelReject()
         - testNowPlayingInfoUpdate()
         - testConnectionStatusDisplay()
      2. Create ClaudeMobile/Tests/NarrationServiceTests.swift:
         - testNarrationTextBuilding()
         - testVoiceConfiguration()
      3. Create ClaudeMobile/Tests/SharedServiceTests.swift:
         - testPairingFlow()
         - testStateSync()
         - testAppGroupAccess()

      Test patterns:
      ```swift
      func testSteeringWheelApprove() async {
          let service = CarPlayService()
          service.state.pendingActions = [mockAction]

          let result = service.handleNextTrackCommand()

          XCTAssertEqual(result, .success)
          XCTAssertTrue(service.state.pendingActions.isEmpty)
      }
      ```
    priority: medium
    parallel_group: 23
    completed: false
    depends_on:
      - "CP8"
      - "CP11"
    verification: |
      [ -f "ClaudeMobile/Tests/CarPlayServiceTests.swift" ] && \
      grep -q 'testSteeringWheel\|XCTAssert' ClaudeMobile/Tests/CarPlayServiceTests.swift && exit 0 || exit 1
    acceptance_criteria:
      - "CarPlayServiceTests with steering wheel tests"
      - "NarrationServiceTests with text building tests"
      - "SharedServiceTests with pairing tests"
      - "All tests pass"
    files:
      - "ClaudeMobile/Tests/CarPlayServiceTests.swift"
      - "ClaudeMobile/Tests/NarrationServiceTests.swift"
      - "ClaudeMobile/Tests/SharedServiceTests.swift"
    tags:
      - carplay
      - testing
      - unit-tests
    commit_template: "test(carplay): Add CarPlay unit tests"

  - id: "CP17"
    title: "Add integration tests for pairing flow"
    description: |
      Create integration tests for the complete pairing flow.

      Implementation:
      1. Create ClaudeMobile/Tests/IntegrationTests.swift:
         - testQRCodePairingFlow()
         - testManualCodePairingFlow()
         - testCarPlayStateSync()
         - testWatchCarPlaySharedState()
      2. Test App Group state sharing
      3. Test cloud relay integration
      4. Mock network responses for testing

      Test pattern:
      ```swift
      func testPairingFlowThroughToCarPlay() async throws {
          let qrCode = "claude-watch://pair?code=ABC-123"
          try await SharedService.shared.handleQRCode(qrCode)

          XCTAssertTrue(SharedService.shared.isPaired)

          let carPlay = CarPlayService()
          await carPlay.syncState()
          XCTAssertEqual(carPlay.connectionStatus, .connected)
      }
      ```
    priority: medium
    parallel_group: 23
    completed: false
    depends_on:
      - "CP16"
    verification: |
      [ -f "ClaudeMobile/Tests/IntegrationTests.swift" ] && \
      grep -q 'testPairing\|testCarPlay' ClaudeMobile/Tests/IntegrationTests.swift && exit 0 || exit 1
    acceptance_criteria:
      - "QR code pairing flow test"
      - "Manual code pairing flow test"
      - "App Group state sharing test"
      - "CarPlay state sync test"
    files:
      - "ClaudeMobile/Tests/IntegrationTests.swift"
    tags:
      - carplay
      - testing
      - integration
    commit_template: "test(carplay): Add integration tests"

  - id: "CP18"
    title: "Add Watch ↔ CarPlay state sync"
    description: |
      Ensure state is properly synchronized between Watch and CarPlay via App Groups.

      Implementation:
      1. Add state change observers in SharedService:
         - Observe pendingActions changes
         - Observe connectionStatus changes
         - Observe sessionState changes
      2. Update both Watch and CarPlay on changes:
         - Use NotificationCenter for local broadcast
         - Use App Group for persistent state
      3. Handle conflicts (both active at same time):
         - Last-write-wins for approval responses
         - Sync pending actions from server as source of truth
      4. Add watchActive/carPlayActive tracking

      Pattern:
      ```swift
      class SharedService {
          @Published var state: SessionState {
              didSet {
                  saveToAppGroup()
                  NotificationCenter.default.post(name: .stateDidChange, object: nil)
              }
          }

          func loadFromAppGroup() {
              // Load state from UserDefaults(suiteName: appGroup)
          }

          func saveToAppGroup() {
              // Save state to UserDefaults(suiteName: appGroup)
          }
      }
      ```
    priority: medium
    parallel_group: 23
    completed: false
    depends_on:
      - "CP3"
      - "CP7"
    verification: |
      grep -q 'watchActive\|carPlayActive\|saveToAppGroup\|loadFromAppGroup' ClaudeMobile/Services/SharedService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "State observers for all changes"
      - "App Group persistence"
      - "NotificationCenter local broadcast"
      - "Conflict resolution strategy"
      - "watchActive/carPlayActive tracking"
    files:
      - "ClaudeMobile/Services/SharedService.swift"
    tags:
      - carplay
      - watch
      - state-sync
      - app-groups
    commit_template: "feat(carplay): Add Watch ↔ CarPlay state sync"

  - id: "CP19"
    title: "Handle edge cases (connection loss, etc.)"
    description: |
      Handle edge cases and error conditions gracefully.

      Implementation:
      1. Connection loss handling:
         - Show CPAlertTemplate on disconnect
         - Auto-reconnect with exponential backoff
         - Audio warning on connection loss
      2. Empty state handling:
         - Show "No pending approvals" in Now Playing
         - Disable steering wheel commands when empty
      3. Rapid action handling:
         - Debounce steering wheel commands (500ms)
         - Queue actions if server slow
      4. App lifecycle handling:
         - Save state on background
         - Restore state on foreground
         - Handle CarPlay disconnect/reconnect
      5. Error feedback:
         - Show CPAlertTemplate on API errors
         - Retry with backoff

      Pattern:
      ```swift
      func handleConnectionLoss() {
          connectionStatus = .disconnected
          audioService.playFeedback(.connectionLost)

          let alert = CPAlertTemplate(
              titleVariants: ["Connection Lost"],
              actions: [CPAlertAction(title: "Retry", style: .default) { _ in
                  self.reconnect()
              }]
          )
          interfaceController?.presentTemplate(alert, animated: true)
      }
      ```
    priority: medium
    parallel_group: 23
    completed: false
    depends_on:
      - "CP10"
    verification: |
      grep -q 'handleConnectionLoss\|CPAlertTemplate\|debounce\|exponentialBackoff' ClaudeMobile/Scenes/CarPlay/CarPlayService.swift && exit 0 || exit 1
    acceptance_criteria:
      - "Connection loss alert with retry"
      - "Empty state handling"
      - "Steering wheel command debouncing"
      - "App lifecycle state preservation"
      - "API error feedback"
    files:
      - "ClaudeMobile/Scenes/CarPlay/CarPlayService.swift"
    tags:
      - carplay
      - error-handling
      - edge-cases
    commit_template: "fix(carplay): Handle edge cases and errors"

  - id: "CP20"
    title: "App Store submission preparation"
    description: |
      Prepare the iOS app for App Store submission.

      Implementation:
      1. Verify all entitlements:
         - CarPlay driving task entitlement
         - App Groups entitlement
         - Push notifications entitlement
         - Siri entitlement
      2. Add required Info.plist keys:
         - NSCameraUsageDescription
         - NSSiriUsageDescription
         - NSMicrophoneUsageDescription (if needed)
      3. Create App Store assets:
         - App icon (all sizes)
         - Screenshots for iPhone
         - Screenshots for CarPlay (simulator)
      4. Write App Store description and keywords
      5. Request CarPlay entitlement from Apple
      6. Test on physical device and real car

      Note: CarPlay apps require Apple approval. Submit entitlement
      request via Apple Developer Portal with app description and
      justification for CarPlay access.
    priority: low
    parallel_group: 23
    completed: false
    depends_on:
      - "CP16"
      - "CP17"
      - "CP18"
      - "CP19"
    verification: |
      [ -f "ClaudeMobile/Info.plist" ] && \
      grep -q 'NSCameraUsageDescription' ClaudeMobile/Info.plist && \
      grep -q 'NSSiriUsageDescription' ClaudeMobile/Info.plist && exit 0 || exit 1
    acceptance_criteria:
      - "All entitlements configured"
      - "All Info.plist keys present"
      - "App icons for all sizes"
      - "CarPlay entitlement requested"
      - "Physical device testing complete"
    files:
      - "ClaudeMobile/Info.plist"
      - "ClaudeMobile/ClaudeMobile.entitlements"
      - "ClaudeMobile/Assets.xcassets/"
    tags:
      - carplay
      - app-store
      - submission
      - final
    commit_template: "chore(carplay): App Store submission preparation"
