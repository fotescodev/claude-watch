#!/usr/bin/env python3
"""
Generate human-readable TASKS.md from tasks.yaml

This script parses tasks.yaml and creates a markdown view for human reference.
It runs automatically when Ralph updates tasks.yaml.

Usage:
    ./generate-tasks-md.py
    python3 generate-tasks-md.py
"""

import os
import sys
from datetime import datetime

def parse_yaml_simple(filepath):
    """Parse tasks.yaml without requiring PyYAML library"""
    with open(filepath, 'r') as f:
        content = f.read()

    tasks = []
    current_task = None
    in_description = False
    in_verification = False

    for line in content.split('\n'):
        line_stripped = line.strip()

        # Skip empty lines and comments
        if not line_stripped or line_stripped.startswith('#'):
            continue

        # New task starts
        if line_stripped.startswith('- id:'):
            if current_task:
                tasks.append(current_task)
            current_task = {
                'id': line_stripped.split('"')[1] if '"' in line_stripped else line_stripped.split("'")[1],
                'title': '',
                'description': '',
                'priority': '',
                'parallel_group': 0,
                'completed': False
            }
            in_description = False
            in_verification = False

        elif current_task:
            if line_stripped.startswith('title:'):
                current_task['title'] = line_stripped.split('"')[1] if '"' in line_stripped else line_stripped.split("'")[1]

            elif line_stripped.startswith('priority:'):
                current_task['priority'] = line_stripped.split(':')[1].strip()

            elif line_stripped.startswith('parallel_group:'):
                current_task['parallel_group'] = int(line_stripped.split(':')[1].strip())

            elif line_stripped.startswith('completed:'):
                current_task['completed'] = 'true' in line_stripped.lower()

            elif line_stripped == 'description: |':
                in_description = True
                in_verification = False

            elif line_stripped == 'verification: |':
                in_verification = True
                in_description = False

            elif in_description and line.startswith('    '):
                # Description content (indented)
                desc_line = line[4:] if len(line) > 4 else ''
                if current_task['description']:
                    current_task['description'] += ' ' + desc_line.strip()
                else:
                    current_task['description'] = desc_line.strip()

            elif line_stripped.startswith('acceptance_criteria:') or \
                 line_stripped.startswith('files:') or \
                 line_stripped.startswith('tags:') or \
                 line_stripped.startswith('commit_template:'):
                in_description = False
                in_verification = False

    # Add last task
    if current_task:
        tasks.append(current_task)

    return tasks

def generate_markdown(tasks):
    """Generate markdown from parsed tasks"""

    # Calculate stats
    total = len(tasks)
    completed = sum(1 for t in tasks if t['completed'])
    pending = total - completed
    progress_pct = int((completed / total * 100)) if total > 0 else 0

    # Group tasks by parallel_group
    groups = {}
    for task in tasks:
        group = task['parallel_group']
        if group not in groups:
            groups[group] = []
        groups[group].append(task)

    # Phase names mapping
    phase_names = {
        1: "Phase 1: Critical - App Store Blockers",
        2: "Phase 2: Critical - Dependencies",
        3: "Phase 3: High Priority - Quality & Polish",
        4: "Phase 4: Medium Priority - Enhancement",
        5: "Phase 5: Liquid Glass",
        6: "Phase 6: Testing"
    }

    # Build markdown
    md = []
    md.append("# Ralph Tasks - Human-Readable View")
    md.append("")
    md.append("> **‚ö†Ô∏è This file is GENERATED from `../tasks.yaml`**  ")
    md.append("> **Do NOT edit this file directly - edit `tasks.yaml` instead**")
    md.append("")
    md.append(f"**Total Tasks:** {total}  ")
    md.append(f"**Completed:** {completed}  ")
    md.append(f"**Pending:** {pending}  ")
    md.append(f"**Progress:** {completed}/{total} ({progress_pct}%)")
    md.append("")
    md.append("---")
    md.append("")

    # Add grouped tasks
    for group_num in sorted(groups.keys()):
        phase_name = phase_names.get(group_num, f"Phase {group_num}")
        md.append(f"## {phase_name}")
        md.append("")
        md.append(f"**Parallel Group {group_num}** - Tasks can run concurrently")
        md.append("")
        md.append("| ID | Title | Priority | Status |")
        md.append("|----|-------|----------|--------|")

        for task in groups[group_num]:
            task_id = f"**{task['id']}**"
            title = task['title']
            priority = task['priority']
            status = "‚úÖ Complete" if task['completed'] else "‚è≥ Pending"
            md.append(f"| {task_id} | {title} | {priority} | {status} |")

        md.append("")
        md.append("---")
        md.append("")

    # Quick reference section
    md.append("## Quick Reference")
    md.append("")

    md.append("### Completed Tasks")
    completed_tasks = [t for t in tasks if t['completed']]
    if completed_tasks:
        for task in completed_tasks:
            md.append(f"- ‚úÖ **{task['id']}**: {task['title']}")
    else:
        md.append("")
    md.append("")

    md.append("### Pending Tasks")
    pending_tasks = [t for t in tasks if not t['completed']]
    if pending_tasks:
        for task in pending_tasks:
            md.append(f"- ‚è≥ **{task['id']}**: {task['title']}")
    else:
        md.append("All tasks complete! üéâ")
    md.append("")

    md.append("---")
    md.append("")
    md.append("## How to Use This File")
    md.append("")
    md.append("This is a **read-only reference** generated from `../tasks.yaml`.")
    md.append("")
    md.append("**To view full task details:**")
    md.append("- Open `../tasks.yaml` for complete definitions")
    md.append("- Each task includes: description, verification commands, acceptance criteria, files to modify")
    md.append("")
    md.append("**To modify tasks:**")
    md.append("1. Edit `../tasks.yaml` directly")
    md.append("2. Ralph will automatically pick up changes on next run")
    md.append("")
    md.append("**To see what Ralph is working on:**")
    md.append("- Check `../session-log.md` for current session")
    md.append("- Run `../monitor-ralph.sh` for live progress")
    md.append("- View `../metrics.json` for statistics")
    md.append("")
    md.append(f"**Last Updated:** Auto-generated from tasks.yaml")
    md.append("")

    return '\n'.join(md)

def main():
    """Main entry point"""
    # Get script directory
    script_dir = os.path.dirname(os.path.abspath(__file__))

    # File paths
    tasks_yaml = os.path.join(script_dir, 'tasks.yaml')
    tasks_md = os.path.join(script_dir, 'ralph-context-docs', 'TASKS.md')

    # Check if tasks.yaml exists
    if not os.path.exists(tasks_yaml):
        print(f"Error: tasks.yaml not found at {tasks_yaml}", file=sys.stderr)
        sys.exit(1)

    # Parse tasks
    try:
        tasks = parse_yaml_simple(tasks_yaml)
        print(f"Parsed {len(tasks)} tasks from tasks.yaml")
    except Exception as e:
        print(f"Error parsing tasks.yaml: {e}", file=sys.stderr)
        sys.exit(1)

    # Generate markdown
    try:
        markdown = generate_markdown(tasks)
        print(f"Generated markdown ({len(markdown)} bytes)")
    except Exception as e:
        print(f"Error generating markdown: {e}", file=sys.stderr)
        sys.exit(1)

    # Ensure ralph-context-docs directory exists
    context_dir = os.path.dirname(tasks_md)
    os.makedirs(context_dir, exist_ok=True)

    # Write output
    try:
        with open(tasks_md, 'w') as f:
            f.write(markdown)
        print(f"Successfully wrote TASKS.md to {tasks_md}")
    except Exception as e:
        print(f"Error writing TASKS.md: {e}", file=sys.stderr)
        sys.exit(1)

    print("‚úÖ TASKS.md updated successfully")

if __name__ == '__main__':
    main()
