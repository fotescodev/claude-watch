# Phase 10 Context: COMP5 Question Response from Watch

> Decisions captured: 2026-01-22
> Robustness review: 2026-01-22
> Participants: dfotesco
> Previous attempt: codex-review branch (failed - see `docs/solutions/integration-issues/comp5-question-proxy-failure-analysis.md`)

## Executive Summary

Phase 10 implements the ability to answer Claude's `AskUserQuestion` prompts from the watch. Unlike tool approvals (which use hooks), questions are output to stdout and require a different approach: spawning Claude as a child process and intercepting I/O.

---

## Problem Statement

```
┌─────────────────────────────────────────────────────────────────┐
│  CURRENT LIMITATION                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Claude asks:  "Which approach should we use?"                 │
│                   1. Approach A (Recommended)                   │
│                   2. Approach B                                 │
│                   3. Other                                      │
│                                                                 │
│   This goes to: STDOUT (no hook!)                               │
│   Answer from:  STDIN (no hook!)                                │
│                                                                 │
│   Watch hooks can ONLY intercept:                               │
│   - PreToolUse (before tool runs)                               │
│   - PostToolUse (after tool runs)                               │
│   - Stop (user presses Esc)                                     │
│                                                                 │
│   Result: Watch CANNOT see or answer questions                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Solution Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│  PHASE 10 SOLUTION: cc-watch run                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   User runs: npx cc-watch run "fix the bug"                     │
│                                                                 │
│   ┌──────────────┐      ┌──────────────┐      ┌──────────────┐ │
│   │  cc-watch    │      │    CLOUD     │      │    WATCH     │ │
│   │  run         │      │              │      │              │ │
│   │              │      │              │      │              │ │
│   │ 1. spawn     │      │              │      │              │ │
│   │    claude    │      │              │      │              │ │
│   │              │      │              │      │              │ │
│   │ 2. intercept │      │              │      │              │ │
│   │    stdout    │      │              │      │              │ │
│   │              │      │              │      │              │ │
│   │ 3. detect    │      │              │      │              │ │
│   │    question  │      │              │      │              │ │
│   │       │      │      │              │      │              │ │
│   │       ▼      │      │              │      │              │ │
│   │ 4. POST ─────┼─────▶│ store + APNs │─────▶│ 5. show UI   │ │
│   │    /question │      │              │      │              │ │
│   │              │      │              │      │              │ │
│   │ 6. poll ◀────┼──────│◀─────────────┼──────│ 7. tap       │ │
│   │    /question │      │              │      │    option    │ │
│   │              │      │              │      │              │ │
│   │ 8. inject    │      │              │      │              │ │
│   │    stdin     │      │              │      │              │ │
│   │    ↓↓Enter   │      │              │      │              │ │
│   │              │      │              │      │              │ │
│   └──────────────┘      └──────────────┘      └──────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## API Contract (SHARED - ALL COMPONENTS MUST MATCH)

### Types

```typescript
// Shared across CLI, Cloud, Watch
interface Question {
  id: string;              // UUID, generated by CLI
  pairingId: string;       // Links to device pair
  prompt: string;          // "Which approach should we use?"
  header?: string;         // "APPROACH" (category label)
  options: QuestionOption[];
  multiSelect: boolean;    // true = checkboxes, false = radio
  timestamp: string;       // ISO 8601
}

interface QuestionOption {
  label: string;           // "Approach A (Recommended)"
  description?: string;    // Optional explanation
}

interface QuestionAnswer {
  questionId: string;
  selectedIndices: number[];  // [0] for single, [0,2] for multi
  skipped: boolean;           // true = user chose to type in terminal
  timestamp: string;
}
```

### Endpoints

| Endpoint | Method | Source | Purpose |
|----------|--------|--------|---------|
| `/question` | POST | CLI | Create question, trigger APNs |
| `/question/{pairingId}` | GET | Watch | Get pending questions for this device |
| `/question/{pairingId}/{questionId}` | GET | CLI | Poll for answer |
| `/question/{pairingId}/{questionId}/answer` | POST | Watch | Submit answer |

### POST /question (CLI → Cloud)

```http
POST /question
Content-Type: application/json

{
  "pairingId": "abc-123",
  "question": {
    "id": "q-456",
    "prompt": "Which approach?",
    "header": "APPROACH",
    "options": [
      { "label": "Approach A", "description": "Recommended" },
      { "label": "Approach B" }
    ],
    "multiSelect": false,
    "timestamp": "2026-01-22T10:00:00Z"
  }
}
```

Response:
```json
{ "success": true }
```

Cloud action:
1. Store in KV: `question:{pairingId}:{questionId}` → question data
2. Send APNs push with `{ type: "question", questionId: "q-456" }`

### GET /question/{pairingId} (Watch → Cloud)

```http
GET /question/abc-123
```

Response:
```json
{
  "questions": [
    {
      "id": "q-456",
      "prompt": "Which approach?",
      "options": [...],
      "multiSelect": false
    }
  ]
}
```

### GET /question/{pairingId}/{questionId} (CLI → Cloud)

```http
GET /question/abc-123/q-456
```

Response (pending):
```json
{ "status": "pending" }
```

Response (answered):
```json
{
  "status": "answered",
  "answer": {
    "selectedIndices": [0],
    "skipped": false
  }
}
```

### POST /question/{pairingId}/{questionId}/answer (Watch → Cloud)

```http
POST /question/abc-123/q-456/answer
Content-Type: application/json

{
  "selectedIndices": [0],
  "skipped": false
}
```

Response:
```json
{ "success": true }
```

---

## Robustness Analysis (2026-01-22)

Comparison of spec vs actual implementation revealed critical gaps that must be fixed.

### CRITICAL: Implementation vs Spec Mismatches

#### 1. Question ID Generation (ROOT CAUSE OF PREVIOUS FAILURE)

| Component | Current Behavior | Required Behavior |
|-----------|------------------|-------------------|
| Cloud `index.ts:499` | Generates `questionId = crypto.randomUUID()` | Accept `id` from request body |
| CLI `stdin-proxy.ts` | Relies on cloud-returned ID | Generate ID before POST |

**Fix Required in Cloud:**
```typescript
// index.ts - Accept client-provided ID
app.post('/question', async (c) => {
  const body = await c.req.json<{ id?: string; pairingId: string; ... }>();
  const questionId = body.id || crypto.randomUUID();  // Client wins
  // ... rest unchanged
});
```

**Fix Required in CLI:**
```typescript
// stdin-proxy.ts - Generate ID before POST
private async createCloudQuestion(question: ParsedQuestion): Promise<string | null> {
  const questionId = crypto.randomUUID();  // Generate locally
  const requestData = {
    id: questionId,  // Send our ID to cloud
    pairingId: this.pairingId,
    question: question.text,
    header: question.header || "Question",
    options: question.options.map((label) => ({ label, description: "" })),
    multiSelect: false,
  };
  // ... POST to cloud
  return questionId;  // Use OUR ID, not response
}
```

#### 2. Never-Resolving Promises (MEMORY LEAK / HANG)

**Current Problem (`stdin-proxy.ts:293, 305`):**
```typescript
// These never resolve, causing Promise.race to hang
if (result.status === "skipped") {
  return new Promise(() => {});  // HANGS FOREVER!
}
return new Promise(() => {});  // On timeout, also hangs
```

**Fix Required:**
```typescript
// Reject instead of hang
if (result.status === "skipped") {
  throw new Error('User chose terminal input');
}
// On timeout:
throw new Error('Watch answer timeout');
```

#### 3. API Path Mismatch (Watch Polling)

| Spec Path | Current Cloud Path |
|-----------|-------------------|
| `GET /question/{pairingId}` | `GET /questions/{pairingId}` (plural) |

**Decision**: Keep current cloud paths (plural `/questions/`), update spec.

### MODERATE: Potential Issues

#### 4. Answer Injection Method

| Method | When to Use |
|--------|-------------|
| Text + newline (`1\n`) | Simple numbered prompts (try first) |
| Escape sequences (`\x1b[B` + `\r`) | Interactive list with arrow navigation |

**Decision**: Start with text+newline. If fails, add escape sequence fallback.

#### 5. Missing Master Timeout

**Current**: No overall timeout on `raceForAnswer()`

**Fix Required:**
```typescript
private async raceForAnswer(questionId: string, optionCount: number): Promise<string> {
  const MASTER_TIMEOUT = 30000;  // 30 seconds (confirmed)

  return Promise.race([
    this.pollWatchAnswer(questionId),
    this.readTerminalInput(optionCount),
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Answer timeout')), MASTER_TIMEOUT)
    ),
  ]);
}
```

### Already Correct (Keep)

| Component | Status |
|-----------|--------|
| QuestionView.swift | Complete - single/multi-select, accessibility, haptics |
| WatchService question methods | Complete - fetchPendingQuestions, answerQuestion |
| Cloud question endpoints (structure) | Correct - just need ID fix |
| E2E test in test-hooks.py | Complete - tests full flow |

---

## Confirmed Decisions (2026-01-22)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **ID generation** | **CLI generates** | Single source of truth, prevents mismatch |
| **Timeout** | **30 seconds** | Matches watch screen timeout, prevents hangs |
| **Answer injection** | Text + newline first | Simpler, likely works for numbered options |
| **Answer fallback** | Escape sequences | If text fails, use arrow keys |
| **API paths** | Keep current (plural) | Avoid breaking existing implementation |

---

## Implementation Plan

### Phase 10.1: Cloud Endpoints (1-2 hours)

**File**: `claude-watch-cloud/src/index.ts`

```typescript
// Add these routes:
router.post('/question', handleCreateQuestion);
router.get('/question/:pairingId', handleGetQuestions);
router.get('/question/:pairingId/:questionId', handlePollAnswer);
router.post('/question/:pairingId/:questionId/answer', handleSubmitAnswer);
```

**KV Schema**:
```
question:{pairingId}:{questionId} → { question: Question, answer?: QuestionAnswer }
questions:{pairingId} → [questionId, questionId, ...]  // List of pending
```

**Test with curl**:
```bash
# Create question
curl -X POST https://claude-watch.fotescodev.workers.dev/question \
  -H "Content-Type: application/json" \
  -d '{"pairingId":"test","question":{"id":"q1","prompt":"Test?","options":[{"label":"Yes"},{"label":"No"}],"multiSelect":false}}'

# Poll for answer
curl https://claude-watch.fotescodev.workers.dev/question/test/q1

# Submit answer
curl -X POST https://claude-watch.fotescodev.workers.dev/question/test/q1/answer \
  -H "Content-Type: application/json" \
  -d '{"selectedIndices":[0],"skipped":false}'

# Poll again (should be answered)
curl https://claude-watch.fotescodev.workers.dev/question/test/q1
```

### Phase 10.2: CLI Question Detection (1-2 hours)

**File**: `claude-watch-npm/src/cli/run.ts` (already started)

Improve question detection:
```typescript
function detectQuestion(buffer: string): DetectedQuestion | null {
  // Pattern 1: Numbered options with "Enter to select"
  // Claude outputs: "Question?\n  1. Option A\n  2. Option B\n\n> Enter to select"

  // Pattern 2: Y/N confirmation
  // Claude outputs: "Proceed? (y/n)"

  // Pattern 3: Bracketed selection
  // Claude outputs: "Choose: [1/2/3]"
}
```

Key requirements:
- Single stdin listener (router pattern)
- Timeout on all promises (30s default)
- Log every state transition

### Phase 10.3: CLI Answer Injection (1 hour)

**Key insight**: Claude's interactive list uses escape sequences, not text input.

```typescript
function buildKeySequence(selectedIndex: number, optionCount: number): string {
  // Options are 0-indexed, cursor starts at 0
  // To select option 2 (index 1): Down, Enter
  // To select option 3 (index 2): Down, Down, Enter

  const down = '\x1b[B';  // Arrow down
  const enter = '\r';     // Enter

  let sequence = '';
  for (let i = 0; i < selectedIndex; i++) {
    sequence += down;
  }
  sequence += enter;

  return sequence;
}

// Multi-select: Space toggles, Enter submits
function buildMultiSelectSequence(indices: number[], optionCount: number): string {
  const down = '\x1b[B';
  const space = ' ';
  const enter = '\r';

  // Sort indices to navigate efficiently
  const sorted = [...indices].sort((a, b) => a - b);

  let sequence = '';
  let currentPos = 0;

  for (const idx of sorted) {
    while (currentPos < idx) {
      sequence += down;
      currentPos++;
    }
    sequence += space;  // Toggle this option
  }

  sequence += enter;  // Submit
  return sequence;
}
```

### Phase 10.4: Watch QuestionView (2-3 hours)

**File**: `ClaudeWatch/Views/QuestionView.swift`

Can reference the working UI from codex-review:
```bash
git show origin/codex-review:ClaudeWatch/Views/QuestionView.swift
```

Key features:
- Single-select: Tap option → immediately submit
- Multi-select: Tap to toggle checkbox → tap "Submit" button
- "Other" option: Opens voice dictation or shows "Answer in terminal" message
- Haptic feedback on selection
- 30-second timeout with auto-dismiss

### Phase 10.5: Watch Service Integration (1-2 hours)

**File**: `ClaudeWatch/Services/WatchService.swift`

Add:
```swift
// Poll for questions
func fetchPendingQuestions() async throws -> [Question]

// Submit answer
func submitQuestionAnswer(questionId: String, selectedIndices: [Int], skipped: Bool) async throws

// Handle push notification
func handleQuestionNotification(questionId: String)
```

### Phase 10.6: Integration Testing (1-2 hours)

Test script:
```bash
#!/bin/bash
# test-question-flow.sh

# 1. Start cc-watch run with a prompt that triggers AskUserQuestion
npx cc-watch run "help me decide between options" &
CLI_PID=$!

# 2. Wait for question to appear
sleep 5

# 3. Check cloud has the question
curl https://claude-watch.fotescodev.workers.dev/question/YOUR_PAIRING_ID

# 4. Submit answer via curl (simulating watch)
curl -X POST https://claude-watch.fotescodev.workers.dev/question/YOUR_PAIRING_ID/QUESTION_ID/answer \
  -d '{"selectedIndices":[0],"skipped":false}'

# 5. Verify CLI received answer and continued
wait $CLI_PID
```

---

## Decision Log

| Decision | Choice | Rationale | Confirmed |
|----------|--------|-----------|-----------|
| ID generation | **CLI generates** | Single source of truth, prevents mismatch | ✅ 2026-01-22 |
| Polling interval | 500ms | Balance between latency and load | |
| Timeout | **30 seconds** | Match watch screen timeout, prevents hangs | ✅ 2026-01-22 |
| Key injection | **Text + newline first**, escape sequences fallback | Simpler approach, add complexity only if needed | ✅ 2026-01-22 |
| Multi-select | Space to toggle | Standard terminal convention | |
| Fallback | "Type in terminal" | Always allow local input | |
| API paths | Keep current (plural `/questions/`) | Avoid breaking existing implementation | ✅ 2026-01-22 |

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Question detection false positives | Require "Enter to select" or similar indicator |
| stdin listener conflicts | Single listener with router pattern |
| Indefinite hangs | Timeout on all async operations |
| Watch not receiving push | Fallback to polling every 2s |
| Wrong option selected | Log sequence, allow retry |

---

## Success Criteria

- [ ] CLI detects AskUserQuestion prompts from stdout
- [ ] Question appears on watch within 2 seconds
- [ ] Tapping option submits answer
- [ ] Claude receives answer and continues
- [ ] Fallback to terminal input works
- [ ] No hangs or silent failures

---

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `claude-watch-cloud/src/index.ts` | Modify | Add 4 question endpoints |
| `claude-watch-npm/src/cli/run.ts` | Modify | Improve detection, add injection |
| `claude-watch-npm/src/cloud/client.ts` | Modify | Update to match API contract |
| `ClaudeWatch/Views/QuestionView.swift` | Create | Question UI |
| `ClaudeWatch/Services/WatchService.swift` | Modify | Add question methods |
| `.claude/plans/phase10-CONTEXT.md` | This file | Decisions |

---

## Pre-Implementation Checklist (Robustness Fixes)

Before starting Phase 10 implementation, these fixes MUST be applied:

### 1. Cloud: Accept Client-Provided Question ID
**File**: `claude-watch-cloud/src/index.ts`
**Line**: ~490-512 (`app.post('/question', ...)`)

```diff
 app.post('/question', async (c) => {
   const body = await c.req.json<{
+    id?: string;
     pairingId: string;
     question: string;
     // ...
   }>();

-  const questionId = crypto.randomUUID();
+  const questionId = body.id || crypto.randomUUID();

   const questionRequest: QuestionRequest = {
     id: questionId,
     // ...
   };
```

### 2. CLI: Generate Question ID Before POST
**File**: `claude-watch-npm/src/cli/stdin-proxy.ts`
**Line**: ~204-237 (`createCloudQuestion`)

```diff
 private async createCloudQuestion(question: ParsedQuestion): Promise<string | null> {
   try {
+    const questionId = crypto.randomUUID();  // Generate locally
     const requestData = {
+      id: questionId,
       pairingId: this.pairingId,
-      type: "question",  // Remove - not in spec
       question: question.text,
       // ...
     };

     const response = await fetch(...);
-    const result = (await response.json()) as { questionId: string };
-    return result.questionId;
+    if (!response.ok) throw new Error(`HTTP ${response.status}`);
+    return questionId;  // Use OUR ID
   }
 }
```

### 3. CLI: Fix Never-Resolving Promises
**File**: `claude-watch-npm/src/cli/stdin-proxy.ts`
**Line**: ~267-306 (`pollWatchAnswer`)

```diff
 private async pollWatchAnswer(questionId: string): Promise<string> {
-  const timeout = 300000; // 5 minutes
+  const timeout = 30000; // 30 seconds
   // ...
   while (Date.now() - startTime < timeout) {
     // ...
     if (result.status === "skipped") {
-      return new Promise(() => {}); // Never resolves
+      throw new Error('User chose terminal input');
     }
   }

-  return new Promise(() => {});
+  throw new Error('Watch answer timeout');
 }
```

### 4. CLI: Add Master Timeout to Race
**File**: `claude-watch-npm/src/cli/stdin-proxy.ts`
**Line**: ~243-262 (`raceForAnswer`)

```diff
 private async raceForAnswer(
   questionId: string,
   optionCount: number
 ): Promise<string> {
+  const MASTER_TIMEOUT = 30000;

   try {
     const answer = await Promise.race([
       this.pollWatchAnswer(questionId),
       this.readTerminalInput(optionCount),
+      new Promise<never>((_, reject) =>
+        setTimeout(() => reject(new Error('Answer timeout')), MASTER_TIMEOUT)
+      ),
     ]);
     return answer;
+  } catch (error) {
+    // If watch times out or user skips, fall back to terminal
+    console.log(chalk.yellow(`  ${(error as Error).message}, waiting for terminal input...`));
+    return this.readTerminalInput(optionCount);
   } finally {
     // ...
   }
 }
```

### 5. Verify Test Coverage
Run existing E2E tests to ensure cloud endpoints still work:
```bash
python3 .claude/hooks/test-hooks.py
```

---

## References

- Previous failure analysis: `docs/solutions/integration-issues/comp5-question-proxy-failure-analysis.md`
- Working QuestionView UI: `git show origin/codex-review:ClaudeWatch/Views/QuestionView.swift`
- DATA_FLOW documentation: `git show origin/codex-review:.claude/DATA_FLOW.md`
- COMP5 original plan: `.claude/plans/COMP5-question-response.md`
